/**
 * Reducers: Transform verbose tool outputs into compact summaries
 * before they hit the LLM or storage-heavy responses.
 *
 * Each reducer stores:
 * - raw_ref: Reference to full raw content
 * - summary: Reduced content for LLM consumption
 * - embedding: For semantic retrieval
 */

export interface ReducerResult {
	summary: string
	shouldStoreRaw: boolean
	extractedMetadata: Record<string, unknown>
}

// ============================================================================
// SOURCE/ABI REDUCER
// ============================================================================

export function reduceSourceCode(raw: string): ReducerResult {
	const lines = raw.split("\n")

	// Extract key elements
	const functions: string[] = []
	const stateVars: string[] = []
	const modifiers: string[] = []
	const requires: string[] = []
	const events: string[] = []
	const errors: string[] = []

	for (const line of lines) {
		const trimmed = line.trim()

		// State variables - match various types
		if (
			trimmed.match(
				/^\s*(mapping|uint\d*|int\d*|address|bool|bytes\d*|string)\s+/,
			) &&
			!trimmed.startsWith("//") &&
			!trimmed.startsWith("*")
		) {
			stateVars.push(trimmed.replace(/;$/, ""))
		}

		// Function signatures
		if (trimmed.match(/^function\s+\w+/)) {
			const sig = trimmed.match(
				/function\s+(\w+)\s*\([^)]*\)(?:\s+(?:external|public|internal|private|view|pure|payable|virtual|override|\s)+)*/,
			)?.[0]
			if (sig) functions.push(sig.trim())
		}

		// Modifiers
		if (trimmed.match(/^modifier\s+\w+/)) {
			const mod = trimmed.match(/modifier\s+(\w+)/)?.[1]
			if (mod) modifiers.push(mod)
		}

		// Require statements (security-relevant)
		if (trimmed.includes("require(") || trimmed.includes("revert(")) {
			requires.push(trimmed)
		}

		// Events
		if (trimmed.match(/^event\s+\w+/)) {
			events.push(trimmed.replace(/;$/, ""))
		}

		// Custom errors
		if (trimmed.match(/^error\s+\w+/)) {
			errors.push(trimmed.replace(/;$/, ""))
		}
	}

	const summary = `## Contract Outline

### State Variables (${stateVars.length})
${stateVars.slice(0, 20).map((v) => `- ${v}`).join("\n")}
${stateVars.length > 20 ? `... and ${stateVars.length - 20} more` : ""}

### Functions (${functions.length})
${functions.slice(0, 30).map((f) => `- ${f}`).join("\n")}
${functions.length > 30 ? `... and ${functions.length - 30} more` : ""}

### Modifiers (${modifiers.length})
${modifiers.map((m) => `- ${m}`).join("\n")}

### Security Checks (${requires.length})
${requires.slice(0, 15).map((r) => `- ${r}`).join("\n")}
${requires.length > 15 ? `... and ${requires.length - 15} more` : ""}

### Events (${events.length})
${events.slice(0, 10).map((e) => `- ${e}`).join("\n")}
${events.length > 10 ? `... and ${events.length - 10} more` : ""}

### Errors (${errors.length})
${errors.slice(0, 10).map((e) => `- ${e}`).join("\n")}
${errors.length > 10 ? `... and ${errors.length - 10} more` : ""}`

	return {
		summary: summary.trim(),
		shouldStoreRaw: true,
		extractedMetadata: {
			functionCount: functions.length,
			stateVarCount: stateVars.length,
			modifierCount: modifiers.length,
			requireCount: requires.length,
			eventCount: events.length,
			errorCount: errors.length,
		},
	}
}

// ============================================================================
// ABI REDUCER
// ============================================================================

export function reduceABI(raw: string): ReducerResult {
	try {
		const abi = JSON.parse(raw)

		if (!Array.isArray(abi)) {
			return {
				summary: `[Invalid ABI - not an array]\n${raw.slice(0, 500)}...`,
				shouldStoreRaw: true,
				extractedMetadata: { parseError: true },
			}
		}

		const functions = abi.filter((item: any) => item.type === "function")
		const events = abi.filter((item: any) => item.type === "event")
		const errors = abi.filter((item: any) => item.type === "error")

		const writeFunctions = functions.filter(
			(f: any) =>
				f.stateMutability !== "view" && f.stateMutability !== "pure",
		)
		const readFunctions = functions.filter(
			(f: any) =>
				f.stateMutability === "view" || f.stateMutability === "pure",
		)

		const formatFunction = (f: any): string => {
			const inputs =
				f.inputs
					?.map((i: any) => `${i.type}${i.name ? " " + i.name : ""}`)
					.join(", ") || ""
			return `${f.name}(${inputs})`
		}

		const summary = `## ABI Summary

### Write Functions (${writeFunctions.length})
${writeFunctions.slice(0, 20).map((f: any) => `- ${formatFunction(f)}`).join("\n")}
${writeFunctions.length > 20 ? `... and ${writeFunctions.length - 20} more` : ""}

### Read Functions (${readFunctions.length})
${readFunctions.slice(0, 15).map((f: any) => `- ${formatFunction(f)}`).join("\n")}
${readFunctions.length > 15 ? `... and ${readFunctions.length - 15} more` : ""}

### Events (${events.length})
${events.slice(0, 10).map((e: any) => `- ${e.name}`).join("\n")}
${events.length > 10 ? `... and ${events.length - 10} more` : ""}

### Errors (${errors.length})
${errors.map((e: any) => `- ${e.name}`).join("\n")}`

		return {
			summary: summary.trim(),
			shouldStoreRaw: true,
			extractedMetadata: {
				totalFunctions: functions.length,
				writeFunctions: writeFunctions.length,
				readFunctions: readFunctions.length,
				eventCount: events.length,
				errorCount: errors.length,
			},
		}
	} catch {
		return {
			summary: `[Invalid ABI - parse error]\n${raw.slice(0, 500)}...`,
			shouldStoreRaw: true,
			extractedMetadata: { parseError: true },
		}
	}
}

// ============================================================================
// GRAPH REDUCER
// ============================================================================

export function reduceGraph(raw: string): ReducerResult {
	try {
		const graph = JSON.parse(raw)

		const nodeCount = graph.nodes?.length || 0
		const edgeCount = graph.edges?.length || 0

		// Extract critical nodes (entry points, value-holding, etc.)
		const criticalNodes =
			graph.nodes?.filter(
				(n: any) => n.holdsValue || n.isEntryPoint || n.risk === "high",
			) || []

		// Count unique contracts
		const uniqueContracts = new Set(
			graph.nodes?.map((n: any) => n.contract) || [],
		)

		const summary = `## Graph Summary

Nodes: ${nodeCount} | Edges: ${edgeCount}

### Critical Nodes (${criticalNodes.length})
${criticalNodes.slice(0, 15).map((n: any) => `- ${n.contract}.${n.function} [${n.risk || "unknown"}]`).join("\n")}
${criticalNodes.length > 15 ? `... and ${criticalNodes.length - 15} more` : ""}

### Coverage
- Contracts: ${uniqueContracts.size}
- Functions: ${nodeCount}
- Call paths: ${edgeCount}`

		return {
			summary: summary.trim(),
			shouldStoreRaw: true,
			extractedMetadata: {
				nodeCount,
				edgeCount,
				criticalNodeCount: criticalNodes.length,
				contractCount: uniqueContracts.size,
			},
		}
	} catch {
		return {
			summary: `[Graph parse error]\n${raw.slice(0, 500)}...`,
			shouldStoreRaw: true,
			extractedMetadata: { parseError: true },
		}
	}
}

// ============================================================================
// INVARIANTS REDUCER
// ============================================================================

export function reduceInvariants(raw: string): ReducerResult {
	try {
		const invariants = JSON.parse(raw)

		if (!Array.isArray(invariants)) {
			return {
				summary: raw.slice(0, 2000),
				shouldStoreRaw: true,
				extractedMetadata: {},
			}
		}

		const byCategory: Record<string, any[]> = {}
		for (const inv of invariants) {
			const cat = inv.category || "unknown"
			if (!byCategory[cat]) byCategory[cat] = []
			byCategory[cat].push(inv)
		}

		const summary = `## Invariants Summary (${invariants.length} total)

${Object.entries(byCategory)
	.map(
		([cat, invs]) =>
			`### ${cat} (${invs.length})
${invs
	.slice(0, 5)
	.map(
		(inv: any) =>
			`- [${inv.severity || "?"}] ${inv.formula || inv.description} (conf: ${((inv.confidence || 0) * 100).toFixed(0)}%)`,
	)
	.join("\n")}
${invs.length > 5 ? `... and ${invs.length - 5} more` : ""}`,
	)
	.join("\n\n")}`

		return {
			summary: summary.trim(),
			shouldStoreRaw: true,
			extractedMetadata: {
				totalInvariants: invariants.length,
				byCategory: Object.fromEntries(
					Object.entries(byCategory).map(([k, v]) => [k, v.length]),
				),
			},
		}
	} catch {
		return {
			summary: raw.slice(0, 2000),
			shouldStoreRaw: true,
			extractedMetadata: {},
		}
	}
}

// ============================================================================
// PATHS/HYPOTHESES REDUCER
// ============================================================================

export function reducePath(raw: string): ReducerResult {
	try {
		const path = JSON.parse(raw)

		const steps = path.steps || []
		const summary = `## Path Summary

Violates: ${path.violatedInvariantId || "unknown"}
Confidence: ${((path.confidence || 0) * 100).toFixed(0)}%
Est. Profit: ${path.estimatedProfit ? `$${path.estimatedProfit.toLocaleString()}` : "unknown"}

### Steps (${steps.length})
${steps
	.map(
		(s: any, i: number) =>
			`${i + 1}. ${s.contract}.${s.function}(${JSON.stringify(s.inputs || {}).slice(0, 50)})`,
	)
	.join("\n")}

### Assumptions
${(path.assumptions || []).map((a: string) => `- ${a}`).join("\n") || "None"}

### Preconditions
${(path.preconditions || []).map((p: string) => `- ${p}`).join("\n") || "None"}`

		return {
			summary: summary.trim(),
			shouldStoreRaw: true,
			extractedMetadata: {
				stepCount: steps.length,
				estimatedProfit: path.estimatedProfit,
				confidence: path.confidence,
			},
		}
	} catch {
		return {
			summary: raw.slice(0, 2000),
			shouldStoreRaw: true,
			extractedMetadata: {},
		}
	}
}

// ============================================================================
// FORGE LOGS REDUCER
// ============================================================================

export function reduceForgeLogs(raw: string): ReducerResult {
	const lines = raw.split("\n")

	// Extract key info
	const testResults: { name: string; status: string; duration?: string }[] = []
	const reverts: string[] = []
	const profits: string[] = []
	const errors: string[] = []

	let totalTests = 0
	let passed = 0
	let failed = 0

	for (const line of lines) {
		// Test results - match various formats
		const testMatch = line.match(
			/\[(PASS|FAIL)\]\s+(.+?)\s+\((\d+(?:\.\d+)?m?s)\)/,
		)
		if (testMatch) {
			totalTests++
			if (testMatch[1] === "PASS") passed++
			else failed++
			testResults.push({
				name: testMatch[2],
				status: testMatch[1],
				duration: testMatch[3],
			})
		}

		// Also match "Suite result:" format
		const suiteMatch = line.match(/Suite result:\s*(ok|FAILED)/)
		if (suiteMatch && !testResults.length) {
			if (suiteMatch[1] === "ok") passed++
			else failed++
		}

		// Revert reasons
		if (
			line.toLowerCase().includes("revert") ||
			line.includes("Revert")
		) {
			reverts.push(line.trim())
		}

		// Profit logs
		if (
			line.toLowerCase().includes("profit") ||
			line.includes("extracted") ||
			line.includes("Profit")
		) {
			profits.push(line.trim())
		}

		// Errors
		if (
			line.includes("Error") ||
			line.includes("error:") ||
			line.includes("ERROR")
		) {
			errors.push(line.trim())
		}
	}

	const summary = `## Forge Test Results

Total: ${totalTests || "unknown"} | Passed: ${passed} | Failed: ${failed}

### Test Results
${testResults.slice(0, 20).map((t) => `- [${t.status}] ${t.name} (${t.duration})`).join("\n")}
${testResults.length > 20 ? `... and ${testResults.length - 20} more` : ""}

### Reverts (${reverts.length})
${reverts.slice(0, 5).map((r) => `- ${r.slice(0, 100)}`).join("\n")}
${reverts.length > 5 ? `... and ${reverts.length - 5} more` : ""}

### Profits
${profits.slice(0, 5).map((p) => `- ${p}`).join("\n") || "None detected"}

### Errors (${errors.length})
${errors.slice(0, 5).map((e) => `- ${e.slice(0, 100)}`).join("\n")}
${errors.length > 5 ? `... and ${errors.length - 5} more` : ""}`

	return {
		summary: summary.trim(),
		shouldStoreRaw: true,
		extractedMetadata: {
			totalTests: totalTests || passed + failed,
			passed,
			failed,
			revertCount: reverts.length,
			errorCount: errors.length,
			profitMentions: profits.length,
		},
	}
}

// ============================================================================
// ADDRESS LIST REDUCER
// ============================================================================

export function reduceAddressList(raw: string): ReducerResult {
	try {
		const addresses = JSON.parse(raw)

		if (!Array.isArray(addresses)) {
			return {
				summary: raw.slice(0, 1000),
				shouldStoreRaw: true,
				extractedMetadata: {},
			}
		}

		const byCategory: Record<string, any[]> = {}
		let valueHolding = 0

		for (const addr of addresses) {
			const cat = addr.category || "unknown"
			if (!byCategory[cat]) byCategory[cat] = []
			byCategory[cat].push(addr)
			if (addr.holdsValue) valueHolding++
		}

		const summary = `## Addresses (${addresses.length} total, ${valueHolding} value-holding)

${Object.entries(byCategory)
	.map(
		([cat, addrs]) =>
			`### ${cat} (${addrs.length})
${addrs
	.slice(0, 5)
	.map(
		(a: any) =>
			`- ${a.address?.slice(0, 10)}...${a.address?.slice(-6)} ${a.name || ""} ${a.holdsValue ? "[VALUE]" : ""}`,
	)
	.join("\n")}
${addrs.length > 5 ? `... and ${addrs.length - 5} more` : ""}`,
	)
	.join("\n\n")}`

		return {
			summary: summary.trim(),
			shouldStoreRaw: true,
			extractedMetadata: {
				totalAddresses: addresses.length,
				valueHolding,
				byCategory: Object.fromEntries(
					Object.entries(byCategory).map(([k, v]) => [k, v.length]),
				),
			},
		}
	} catch {
		return {
			summary: raw.slice(0, 1000),
			shouldStoreRaw: true,
			extractedMetadata: {},
		}
	}
}

// ============================================================================
// GENERIC REDUCER (first/last window + size)
// ============================================================================

export function reduceGeneric(raw: string, maxLength = 2000): ReducerResult {
	if (raw.length <= maxLength) {
		return {
			summary: raw,
			shouldStoreRaw: false,
			extractedMetadata: { originalLength: raw.length },
		}
	}

	const halfWindow = Math.floor((maxLength - 50) / 2)
	const summary = `${raw.slice(0, halfWindow)}\n\n... [${raw.length - maxLength} chars omitted] ...\n\n${raw.slice(-halfWindow)}`

	return {
		summary,
		shouldStoreRaw: true,
		extractedMetadata: { originalLength: raw.length },
	}
}

// ============================================================================
// REDUCER DISPATCHER
// ============================================================================

export function reduceByKind(kind: string, raw: string): ReducerResult {
	switch (kind) {
		case "source":
			return reduceSourceCode(raw)
		case "abi":
			return reduceABI(raw)
		case "graph":
			return reduceGraph(raw)
		case "invariant":
			return reduceInvariants(raw)
		case "path":
		case "hypothesis":
			return reducePath(raw)
		case "forge_output":
		case "execution":
			return reduceForgeLogs(raw)
		case "contract_outline":
			return reduceSourceCode(raw)
		default:
			return reduceGeneric(raw)
	}
}

// Export all reducers
export const reducers = {
	reduceSourceCode,
	reduceABI,
	reduceGraph,
	reduceInvariants,
	reducePath,
	reduceForgeLogs,
	reduceAddressList,
	reduceGeneric,
	reduceByKind,
} as const
