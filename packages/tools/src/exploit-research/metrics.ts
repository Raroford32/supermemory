/**
 * Metrics tracking for the exploit research system
 *
 * Tracks:
 * - Tokens saved (via reducers)
 * - Retrieval hit rate
 * - Dedup rejections
 * - Phase coverage
 * - Execution pass rate
 */

import type { Phase, TestStatus } from "@repo/validation/exploit-research-schemas"

// ============================================================================
// METRIC TYPES
// ============================================================================

export interface TokenMetrics {
	inputTokens: number
	outputTokens: number
	tokensSaved: number
	reductionRatio: number
	costUsd: number
}

export interface RetrievalMetrics {
	totalQueries: number
	successfulQueries: number
	hitRate: number
	averageResultCount: number
	averageLatencyMs: number
}

export interface DedupMetrics {
	totalChecks: number
	duplicatesRejected: number
	rejectionRate: number
	averageNoveltyScore: number
	noveltyScoreDistribution: {
		low: number // 0-0.33
		medium: number // 0.33-0.66
		high: number // 0.66-1
	}
}

export interface PhaseMetrics {
	phase: Phase
	startedAt: Date
	completedAt: Date | null
	coverage: number // 0-100
	artifactsGenerated: number
	tokensUsed: number
}

export interface ExecutionMetrics {
	totalTests: number
	passed: number
	failed: number
	flaky: number
	inconclusive: number
	error: number
	passRate: number
	profitableCount: number
	totalProfit: number
	averageProfit: number
}

export interface SeasonMetrics {
	seasonId: string
	protocolId: string
	startedAt: Date
	updatedAt: Date
	tokens: TokenMetrics
	retrieval: RetrievalMetrics
	dedup: DedupMetrics
	phases: Record<Phase, PhaseMetrics | null>
	execution: ExecutionMetrics
}

// ============================================================================
// METRICS COLLECTOR
// ============================================================================

/**
 * Create a metrics collector for a season
 */
export function createMetricsCollector(
	seasonId: string,
	protocolId: string,
): MetricsCollector {
	return new MetricsCollector(seasonId, protocolId)
}

export class MetricsCollector {
	private metrics: SeasonMetrics

	constructor(seasonId: string, protocolId: string) {
		this.metrics = {
			seasonId,
			protocolId,
			startedAt: new Date(),
			updatedAt: new Date(),
			tokens: {
				inputTokens: 0,
				outputTokens: 0,
				tokensSaved: 0,
				reductionRatio: 0,
				costUsd: 0,
			},
			retrieval: {
				totalQueries: 0,
				successfulQueries: 0,
				hitRate: 0,
				averageResultCount: 0,
				averageLatencyMs: 0,
			},
			dedup: {
				totalChecks: 0,
				duplicatesRejected: 0,
				rejectionRate: 0,
				averageNoveltyScore: 0,
				noveltyScoreDistribution: {
					low: 0,
					medium: 0,
					high: 0,
				},
			},
			phases: {
				intake: null,
				graphing: null,
				invariant: null,
				violation: null,
				poc_generation: null,
				execution: null,
				refinement: null,
			},
			execution: {
				totalTests: 0,
				passed: 0,
				failed: 0,
				flaky: 0,
				inconclusive: 0,
				error: 0,
				passRate: 0,
				profitableCount: 0,
				totalProfit: 0,
				averageProfit: 0,
			},
		}
	}

	// ============================================================================
	// TOKEN TRACKING
	// ============================================================================

	/**
	 * Record token usage for a tool call
	 */
	recordTokenUsage(data: {
		inputTokens: number
		outputTokens: number
		rawLength: number
		reducedLength: number
		costUsd?: number
	}): void {
		this.metrics.tokens.inputTokens += data.inputTokens
		this.metrics.tokens.outputTokens += data.outputTokens

		// Estimate tokens saved (rough: 1 token ~= 4 chars)
		const estimatedRawTokens = Math.ceil(data.rawLength / 4)
		const estimatedReducedTokens = Math.ceil(data.reducedLength / 4)
		const saved = Math.max(0, estimatedRawTokens - estimatedReducedTokens)
		this.metrics.tokens.tokensSaved += saved

		// Update reduction ratio
		if (this.metrics.tokens.inputTokens > 0) {
			this.metrics.tokens.reductionRatio =
				this.metrics.tokens.tokensSaved /
				(this.metrics.tokens.inputTokens + this.metrics.tokens.tokensSaved)
		}

		if (data.costUsd) {
			this.metrics.tokens.costUsd += data.costUsd
		}

		this.metrics.updatedAt = new Date()
	}

	// ============================================================================
	// RETRIEVAL TRACKING
	// ============================================================================

	/**
	 * Record a retrieval query
	 */
	recordRetrievalQuery(data: {
		resultCount: number
		latencyMs: number
		success: boolean
	}): void {
		this.metrics.retrieval.totalQueries++

		if (data.success && data.resultCount > 0) {
			this.metrics.retrieval.successfulQueries++
		}

		// Update hit rate
		this.metrics.retrieval.hitRate =
			this.metrics.retrieval.successfulQueries /
			this.metrics.retrieval.totalQueries

		// Update average result count (running average)
		const prevTotal =
			this.metrics.retrieval.averageResultCount *
			(this.metrics.retrieval.totalQueries - 1)
		this.metrics.retrieval.averageResultCount =
			(prevTotal + data.resultCount) / this.metrics.retrieval.totalQueries

		// Update average latency (running average)
		const prevLatencyTotal =
			this.metrics.retrieval.averageLatencyMs *
			(this.metrics.retrieval.totalQueries - 1)
		this.metrics.retrieval.averageLatencyMs =
			(prevLatencyTotal + data.latencyMs) / this.metrics.retrieval.totalQueries

		this.metrics.updatedAt = new Date()
	}

	// ============================================================================
	// DEDUP TRACKING
	// ============================================================================

	/**
	 * Record a dedup check
	 */
	recordDedupCheck(data: {
		isDuplicate: boolean
		noveltyScore: number
	}): void {
		this.metrics.dedup.totalChecks++

		if (data.isDuplicate) {
			this.metrics.dedup.duplicatesRejected++
		}

		// Update rejection rate
		this.metrics.dedup.rejectionRate =
			this.metrics.dedup.duplicatesRejected / this.metrics.dedup.totalChecks

		// Update average novelty score (running average)
		const prevTotal =
			this.metrics.dedup.averageNoveltyScore *
			(this.metrics.dedup.totalChecks - 1)
		this.metrics.dedup.averageNoveltyScore =
			(prevTotal + data.noveltyScore) / this.metrics.dedup.totalChecks

		// Update distribution
		if (data.noveltyScore < 0.33) {
			this.metrics.dedup.noveltyScoreDistribution.low++
		} else if (data.noveltyScore < 0.66) {
			this.metrics.dedup.noveltyScoreDistribution.medium++
		} else {
			this.metrics.dedup.noveltyScoreDistribution.high++
		}

		this.metrics.updatedAt = new Date()
	}

	// ============================================================================
	// PHASE TRACKING
	// ============================================================================

	/**
	 * Start tracking a phase
	 */
	startPhase(phase: Phase): void {
		this.metrics.phases[phase] = {
			phase,
			startedAt: new Date(),
			completedAt: null,
			coverage: 0,
			artifactsGenerated: 0,
			tokensUsed: 0,
		}
		this.metrics.updatedAt = new Date()
	}

	/**
	 * Update phase progress
	 */
	updatePhaseProgress(
		phase: Phase,
		data: Partial<{
			coverage: number
			artifactsGenerated: number
			tokensUsed: number
		}>,
	): void {
		const phaseMetrics = this.metrics.phases[phase]
		if (phaseMetrics) {
			if (data.coverage !== undefined) phaseMetrics.coverage = data.coverage
			if (data.artifactsGenerated !== undefined) {
				phaseMetrics.artifactsGenerated += data.artifactsGenerated
			}
			if (data.tokensUsed !== undefined) {
				phaseMetrics.tokensUsed += data.tokensUsed
			}
		}
		this.metrics.updatedAt = new Date()
	}

	/**
	 * Complete a phase
	 */
	completePhase(phase: Phase, coverage?: number): void {
		const phaseMetrics = this.metrics.phases[phase]
		if (phaseMetrics) {
			phaseMetrics.completedAt = new Date()
			if (coverage !== undefined) {
				phaseMetrics.coverage = coverage
			}
		}
		this.metrics.updatedAt = new Date()
	}

	// ============================================================================
	// EXECUTION TRACKING
	// ============================================================================

	/**
	 * Record a test execution result
	 */
	recordExecution(data: {
		status: TestStatus
		profit?: number
	}): void {
		this.metrics.execution.totalTests++

		switch (data.status) {
			case "pass":
				this.metrics.execution.passed++
				break
			case "fail":
				this.metrics.execution.failed++
				break
			case "flaky":
				this.metrics.execution.flaky++
				break
			case "inconclusive":
				this.metrics.execution.inconclusive++
				break
			case "error":
				this.metrics.execution.error++
				break
		}

		// Update pass rate
		this.metrics.execution.passRate =
			this.metrics.execution.passed / this.metrics.execution.totalTests

		// Track profit
		if (data.profit && data.profit > 0) {
			this.metrics.execution.profitableCount++
			this.metrics.execution.totalProfit += data.profit
			this.metrics.execution.averageProfit =
				this.metrics.execution.totalProfit /
				this.metrics.execution.profitableCount
		}

		this.metrics.updatedAt = new Date()
	}

	// ============================================================================
	// GETTERS
	// ============================================================================

	/**
	 * Get all metrics
	 */
	getMetrics(): SeasonMetrics {
		return { ...this.metrics }
	}

	/**
	 * Get token metrics
	 */
	getTokenMetrics(): TokenMetrics {
		return { ...this.metrics.tokens }
	}

	/**
	 * Get retrieval metrics
	 */
	getRetrievalMetrics(): RetrievalMetrics {
		return { ...this.metrics.retrieval }
	}

	/**
	 * Get dedup metrics
	 */
	getDedupMetrics(): DedupMetrics {
		return { ...this.metrics.dedup }
	}

	/**
	 * Get execution metrics
	 */
	getExecutionMetrics(): ExecutionMetrics {
		return { ...this.metrics.execution }
	}

	/**
	 * Get phase coverage summary
	 */
	getPhaseCoverage(): Record<Phase, number> {
		const coverage: Record<string, number> = {}
		for (const [phase, metrics] of Object.entries(this.metrics.phases)) {
			coverage[phase] = metrics?.coverage ?? 0
		}
		return coverage as Record<Phase, number>
	}

	/**
	 * Get summary report
	 */
	getSummaryReport(): string {
		const m = this.metrics

		return `## Season Metrics Summary

### Token Usage
- Input tokens: ${m.tokens.inputTokens.toLocaleString()}
- Output tokens: ${m.tokens.outputTokens.toLocaleString()}
- Tokens saved: ${m.tokens.tokensSaved.toLocaleString()} (${(m.tokens.reductionRatio * 100).toFixed(1)}% reduction)
- Cost: $${m.tokens.costUsd.toFixed(4)}

### Retrieval Performance
- Total queries: ${m.retrieval.totalQueries}
- Hit rate: ${(m.retrieval.hitRate * 100).toFixed(1)}%
- Average results: ${m.retrieval.averageResultCount.toFixed(1)}
- Average latency: ${m.retrieval.averageLatencyMs.toFixed(0)}ms

### Dedup Effectiveness
- Total checks: ${m.dedup.totalChecks}
- Duplicates rejected: ${m.dedup.duplicatesRejected} (${(m.dedup.rejectionRate * 100).toFixed(1)}%)
- Average novelty: ${(m.dedup.averageNoveltyScore * 100).toFixed(1)}%

### Execution Results
- Total tests: ${m.execution.totalTests}
- Pass rate: ${(m.execution.passRate * 100).toFixed(1)}% (${m.execution.passed}/${m.execution.totalTests})
- Profitable: ${m.execution.profitableCount}
- Total profit: $${m.execution.totalProfit.toLocaleString()}
- Average profit: $${m.execution.averageProfit.toLocaleString()}`
	}

	/**
	 * Reset all metrics
	 */
	reset(): void {
		const seasonId = this.metrics.seasonId
		const protocolId = this.metrics.protocolId
		this.metrics = {
			seasonId,
			protocolId,
			startedAt: new Date(),
			updatedAt: new Date(),
			tokens: {
				inputTokens: 0,
				outputTokens: 0,
				tokensSaved: 0,
				reductionRatio: 0,
				costUsd: 0,
			},
			retrieval: {
				totalQueries: 0,
				successfulQueries: 0,
				hitRate: 0,
				averageResultCount: 0,
				averageLatencyMs: 0,
			},
			dedup: {
				totalChecks: 0,
				duplicatesRejected: 0,
				rejectionRate: 0,
				averageNoveltyScore: 0,
				noveltyScoreDistribution: {
					low: 0,
					medium: 0,
					high: 0,
				},
			},
			phases: {
				intake: null,
				graphing: null,
				invariant: null,
				violation: null,
				poc_generation: null,
				execution: null,
				refinement: null,
			},
			execution: {
				totalTests: 0,
				passed: 0,
				failed: 0,
				flaky: 0,
				inconclusive: 0,
				error: 0,
				passRate: 0,
				profitableCount: 0,
				totalProfit: 0,
				averageProfit: 0,
			},
		}
	}

	/**
	 * Export metrics as JSON
	 */
	toJSON(): string {
		return JSON.stringify(this.metrics, null, 2)
	}

	/**
	 * Import metrics from JSON
	 */
	fromJSON(json: string): void {
		const parsed = JSON.parse(json) as SeasonMetrics
		this.metrics = {
			...parsed,
			startedAt: new Date(parsed.startedAt),
			updatedAt: new Date(parsed.updatedAt),
		}
	}
}

// ============================================================================
// EXPORTS
// ============================================================================

export const metrics = {
	createMetricsCollector,
	MetricsCollector,
} as const
