/**
 * Dedup & Novelty Scoring
 *
 * Functions for detecting duplicates and calculating novelty scores
 * to prevent repetitive hypotheses and tests.
 */

/**
 * Calculate cosine similarity between two vectors
 * Vectors should be normalized (unit vectors) for best results
 */
export function cosineSimilarity(vectorA: number[], vectorB: number[]): number {
	if (vectorA.length !== vectorB.length) {
		throw new Error("Vectors must have the same length")
	}

	if (vectorA.length === 0) {
		return 0
	}

	let dotProduct = 0
	let normA = 0
	let normB = 0

	for (let i = 0; i < vectorA.length; i++) {
		const a = vectorA[i]!
		const b = vectorB[i]!

		if (typeof a !== "number" || typeof b !== "number" || isNaN(a) || isNaN(b)) {
			throw new Error("Vectors must contain only valid numbers")
		}

		dotProduct += a * b
		normA += a * a
		normB += b * b
	}

	const magnitudeA = Math.sqrt(normA)
	const magnitudeB = Math.sqrt(normB)

	if (magnitudeA === 0 || magnitudeB === 0) {
		return 0
	}

	return dotProduct / (magnitudeA * magnitudeB)
}

export interface DedupResult {
	isDuplicate: boolean
	maxSimilarity: number
	duplicateOf: string | null
	noveltyScore: number
}

export interface DedupConfig {
	duplicateThreshold: number // Default: 0.92
	similarityThreshold: number // Default: 0.85
	noveltyPenalties: Record<string, number>
}

const DEFAULT_CONFIG: DedupConfig = {
	duplicateThreshold: 0.92,
	similarityThreshold: 0.85,
	noveltyPenalties: {
		// Penalize overused attack patterns
		first_depositor: 0.3,
		simple_mev: 0.25,
		basic_flash_loan: 0.2,
		oracle_manipulation: 0.15,
		reentrancy: 0.1,
	},
}

export interface EmbeddingEntry {
	id: string
	embedding: number[]
	metadata?: Record<string, unknown>
}

/**
 * Check if an embedding represents a duplicate within existing embeddings
 */
export function checkDuplicate(
	newEmbedding: number[],
	existingEmbeddings: EmbeddingEntry[],
	config: Partial<DedupConfig> = {},
): DedupResult {
	const cfg = { ...DEFAULT_CONFIG, ...config }

	let maxSimilarity = 0
	let duplicateOf: string | null = null

	for (const existing of existingEmbeddings) {
		const similarity = cosineSimilarity(newEmbedding, existing.embedding)
		if (similarity > maxSimilarity) {
			maxSimilarity = similarity
			duplicateOf = existing.id
		}
	}

	const isDuplicate = maxSimilarity >= cfg.duplicateThreshold

	return {
		isDuplicate,
		maxSimilarity,
		duplicateOf: isDuplicate ? duplicateOf : null,
		noveltyScore: 1 - maxSimilarity,
	}
}

/**
 * Calculate novelty score with pattern penalties
 */
export function calculateNoveltyScore(
	embedding: number[],
	existingEmbeddings: EmbeddingEntry[],
	category: string | null,
	config: Partial<DedupConfig> = {},
): number {
	const cfg = { ...DEFAULT_CONFIG, ...config }

	// Base novelty from max similarity
	let maxSimilarity = 0
	for (const existing of existingEmbeddings) {
		const similarity = cosineSimilarity(embedding, existing.embedding)
		if (similarity > maxSimilarity) {
			maxSimilarity = similarity
		}
	}

	let noveltyScore = 1 - maxSimilarity

	// Apply category penalty
	if (category && cfg.noveltyPenalties[category]) {
		noveltyScore *= 1 - cfg.noveltyPenalties[category]
	}

	// Count similar existing patterns and reduce novelty
	const similarCount = existingEmbeddings.filter(
		(e) => cosineSimilarity(embedding, e.embedding) > cfg.similarityThreshold,
	).length

	if (similarCount > 0) {
		noveltyScore *= Math.pow(0.9, similarCount)
	}

	return Math.max(0, Math.min(1, noveltyScore))
}

/**
 * Filter duplicates from a batch of candidates
 * Returns only non-duplicate candidates with novelty scores
 */
export function filterDuplicates<T extends { embedding: number[] }>(
	candidates: T[],
	existingEmbeddings: EmbeddingEntry[],
	config: Partial<DedupConfig> = {},
): Array<T & { noveltyScore: number }> {
	const cfg = { ...DEFAULT_CONFIG, ...config }
	const results: Array<T & { noveltyScore: number }> = []
	const seenEmbeddings: EmbeddingEntry[] = [...existingEmbeddings]

	for (const candidate of candidates) {
		const dedup = checkDuplicate(candidate.embedding, seenEmbeddings, cfg)

		if (!dedup.isDuplicate) {
			results.push({
				...candidate,
				noveltyScore: dedup.noveltyScore,
			})

			// Add to seen for intra-batch dedup
			seenEmbeddings.push({
				id: `new-${results.length}`,
				embedding: candidate.embedding,
			})
		}
	}

	return results
}

/**
 * Find most similar items to a given embedding
 */
export function findMostSimilar(
	embedding: number[],
	existingEmbeddings: EmbeddingEntry[],
	limit = 5,
	minSimilarity = 0,
): Array<EmbeddingEntry & { similarity: number }> {
	const withSimilarity = existingEmbeddings
		.map((entry) => ({
			...entry,
			similarity: cosineSimilarity(embedding, entry.embedding),
		}))
		.filter((entry) => entry.similarity >= minSimilarity)
		.sort((a, b) => b.similarity - a.similarity)

	return withSimilarity.slice(0, limit)
}

/**
 * Batch similarity check - useful for large-scale dedup
 */
export function batchSimilarityCheck(
	embeddings: number[][],
	existingEmbeddings: EmbeddingEntry[],
	threshold = 0.85,
): Array<{
	index: number
	isDuplicate: boolean
	maxSimilarity: number
	duplicateOf: string | null
}> {
	return embeddings.map((embedding, index) => {
		let maxSimilarity = 0
		let duplicateOf: string | null = null

		for (const existing of existingEmbeddings) {
			const similarity = cosineSimilarity(embedding, existing.embedding)
			if (similarity > maxSimilarity) {
				maxSimilarity = similarity
				duplicateOf = existing.id
			}
		}

		return {
			index,
			isDuplicate: maxSimilarity >= threshold,
			maxSimilarity,
			duplicateOf: maxSimilarity >= threshold ? duplicateOf : null,
		}
	})
}

/**
 * Calculate diversity score for a set of embeddings
 * Higher score = more diverse set
 */
export function calculateDiversity(embeddings: number[][]): number {
	if (embeddings.length < 2) {
		return 1 // Single item is maximally diverse with itself
	}

	let totalSimilarity = 0
	let comparisons = 0

	for (let i = 0; i < embeddings.length; i++) {
		for (let j = i + 1; j < embeddings.length; j++) {
			totalSimilarity += cosineSimilarity(embeddings[i]!, embeddings[j]!)
			comparisons++
		}
	}

	const avgSimilarity = totalSimilarity / comparisons
	return 1 - avgSimilarity // Convert similarity to diversity
}

// Export all functions
export const dedup = {
	cosineSimilarity,
	checkDuplicate,
	calculateNoveltyScore,
	filterDuplicates,
	findMostSimilar,
	batchSimilarityCheck,
	calculateDiversity,
} as const
