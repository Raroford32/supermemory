import { describe, it, expect } from "vitest"
import {
	cosineSimilarity,
	checkDuplicate,
	calculateNoveltyScore,
	filterDuplicates,
	findMostSimilar,
	batchSimilarityCheck,
	calculateDiversity,
	type DedupConfig,
	type EmbeddingEntry,
} from "../dedup"

describe("Dedup & Novelty", () => {
	// Helper to create a deterministic embedding based on seed
	const createEmbedding = (seed: number, dim = 1536): number[] => {
		const embedding: number[] = []
		for (let i = 0; i < dim; i++) {
			embedding.push(Math.sin(seed * (i + 1)) * 0.1)
		}
		// Normalize
		const norm = Math.sqrt(embedding.reduce((sum, x) => sum + x * x, 0))
		return embedding.map((x) => x / norm)
	}

	// Helper to create similar embedding with small noise
	const createSimilarEmbedding = (base: number[], noise = 0.05): number[] => {
		const seededRandom = (i: number) => {
			const x = Math.sin(i * 12.9898 + i * 78.233) * 43758.5453
			return x - Math.floor(x) - 0.5
		}
		const noisy = base.map((x, i) => x + seededRandom(i) * noise)
		const norm = Math.sqrt(noisy.reduce((sum, x) => sum + x * x, 0))
		return noisy.map((x) => x / norm)
	}

	describe("cosineSimilarity", () => {
		it("should return 1 for identical vectors", () => {
			const vec = [0.1, 0.2, 0.3, 0.4, 0.5]
			const norm = Math.sqrt(vec.reduce((s, x) => s + x * x, 0))
			const normalized = vec.map((x) => x / norm)

			const similarity = cosineSimilarity(normalized, normalized)
			expect(similarity).toBeCloseTo(1.0, 5)
		})

		it("should return 0 for orthogonal vectors", () => {
			const vec1 = [1, 0, 0]
			const vec2 = [0, 1, 0]

			const similarity = cosineSimilarity(vec1, vec2)
			expect(similarity).toBeCloseTo(0, 5)
		})

		it("should return -1 for opposite vectors", () => {
			const vec1 = [1, 0, 0]
			const vec2 = [-1, 0, 0]

			const similarity = cosineSimilarity(vec1, vec2)
			expect(similarity).toBeCloseTo(-1, 5)
		})

		it("should throw for different length vectors", () => {
			expect(() => cosineSimilarity([1, 2], [1, 2, 3])).toThrow(
				"Vectors must have the same length",
			)
		})

		it("should throw for invalid numbers", () => {
			expect(() => cosineSimilarity([1, NaN], [1, 2])).toThrow(
				"Vectors must contain only valid numbers",
			)
		})

		it("should return 0 for zero vectors", () => {
			const similarity = cosineSimilarity([0, 0, 0], [1, 0, 0])
			expect(similarity).toBe(0)
		})

		it("should handle empty vectors", () => {
			const similarity = cosineSimilarity([], [])
			expect(similarity).toBe(0)
		})
	})

	describe("checkDuplicate", () => {
		it("should detect exact duplicates", () => {
			const embedding = createEmbedding(1)
			const existing: EmbeddingEntry[] = [{ id: "existing-1", embedding }]

			const result = checkDuplicate(embedding, existing)

			expect(result.isDuplicate).toBe(true)
			expect(result.maxSimilarity).toBeCloseTo(1.0, 2)
			expect(result.duplicateOf).toBe("existing-1")
		})

		it("should detect near-duplicates above threshold", () => {
			const base = createEmbedding(1)
			const similar = createSimilarEmbedding(base, 0.02)
			const existing: EmbeddingEntry[] = [{ id: "existing-1", embedding: base }]

			const result = checkDuplicate(similar, existing, {
				duplicateThreshold: 0.95,
			})

			expect(result.isDuplicate).toBe(true)
			expect(result.maxSimilarity).toBeGreaterThan(0.95)
		})

		it("should not flag different embeddings as duplicates", () => {
			const embedding1 = createEmbedding(1)
			const embedding2 = createEmbedding(100)
			const existing: EmbeddingEntry[] = [
				{ id: "existing-1", embedding: embedding1 },
			]

			const result = checkDuplicate(embedding2, existing)

			expect(result.isDuplicate).toBe(false)
			expect(result.maxSimilarity).toBeLessThan(0.5)
			expect(result.duplicateOf).toBeNull()
		})

		it("should handle empty existing array", () => {
			const embedding = createEmbedding(1)

			const result = checkDuplicate(embedding, [])

			expect(result.isDuplicate).toBe(false)
			expect(result.maxSimilarity).toBe(0)
			expect(result.noveltyScore).toBe(1)
		})

		it("should find most similar among multiple existing", () => {
			const target = createEmbedding(5)
			const existing: EmbeddingEntry[] = [
				{ id: "far-1", embedding: createEmbedding(100) },
				{ id: "close-1", embedding: createSimilarEmbedding(target, 0.01) },
				{ id: "far-2", embedding: createEmbedding(200) },
			]

			const result = checkDuplicate(target, existing)

			expect(result.duplicateOf).toBe("close-1")
			expect(result.maxSimilarity).toBeGreaterThan(0.9)
		})
	})

	describe("calculateNoveltyScore", () => {
		it("should return 1 for completely novel embedding", () => {
			const embedding = createEmbedding(1)

			const score = calculateNoveltyScore(embedding, [], null)

			expect(score).toBe(1)
		})

		it("should penalize overused patterns", () => {
			const embedding = createEmbedding(1)

			const scoreWithPenalty = calculateNoveltyScore(
				embedding,
				[],
				"first_depositor",
			)
			const scoreWithoutPenalty = calculateNoveltyScore(
				embedding,
				[],
				"custom",
			)

			expect(scoreWithPenalty).toBeLessThan(scoreWithoutPenalty)
		})

		it("should reduce novelty for similar existing patterns", () => {
			// Use more distinct embeddings to ensure they're above similarity threshold
			const base = createEmbedding(1)
			const similar1 = createEmbedding(2) // Different but not too far
			const similar2 = createEmbedding(3)
			const newEmbedding = base // Same as base for consistent comparison

			const existingNone = calculateNoveltyScore(newEmbedding, [], null)
			const existingOne = calculateNoveltyScore(
				newEmbedding,
				[{ id: "1", embedding: similar1 }],
				null,
			)

			// With no existing patterns, novelty should be 1
			expect(existingNone).toBe(1)
			// With some existing patterns (even if not similar), novelty should still be less
			// due to the max similarity calculation
			expect(existingOne).toBeLessThanOrEqual(existingNone)
		})

		it("should return score between 0 and 1", () => {
			const embedding = createEmbedding(1)
			const existing = Array(10)
				.fill(0)
				.map((_, i) => ({
					id: `existing-${i}`,
					embedding: createEmbedding(i + 2),
				}))

			const score = calculateNoveltyScore(
				embedding,
				existing,
				"first_depositor",
			)

			expect(score).toBeGreaterThanOrEqual(0)
			expect(score).toBeLessThanOrEqual(1)
		})

		it("should handle unknown category without penalty", () => {
			const embedding = createEmbedding(1)

			const score = calculateNoveltyScore(embedding, [], "unknown_category")

			expect(score).toBe(1) // No penalty for unknown category
		})
	})

	describe("filterDuplicates", () => {
		it("should remove duplicates from batch", () => {
			const base = createEmbedding(1)
			const candidates = [
				{ id: "c1", embedding: createEmbedding(1) },
				{ id: "c2", embedding: createSimilarEmbedding(base, 0.01) }, // Duplicate of c1
				{ id: "c3", embedding: createEmbedding(50) }, // Different
				{ id: "c4", embedding: createSimilarEmbedding(base, 0.01) }, // Duplicate of c1
			]

			const filtered = filterDuplicates(candidates, [])

			expect(filtered.length).toBeLessThan(candidates.length)
			expect(filtered.every((c) => c.noveltyScore !== undefined)).toBe(true)
		})

		it("should also check against existing embeddings", () => {
			const existingEmbedding = createEmbedding(1)
			const existing: EmbeddingEntry[] = [
				{ id: "existing-1", embedding: existingEmbedding },
			]

			const candidates = [
				{
					id: "c1",
					embedding: createSimilarEmbedding(existingEmbedding, 0.01),
				}, // Dup of existing
				{ id: "c2", embedding: createEmbedding(100) }, // Different
			]

			const filtered = filterDuplicates(candidates, existing)

			expect(filtered.length).toBe(1)
			expect(filtered[0]!.id).toBe("c2")
		})

		it("should include novelty scores in results", () => {
			const candidates = [
				{ id: "c1", embedding: createEmbedding(1) },
				{ id: "c2", embedding: createEmbedding(2) },
			]

			const filtered = filterDuplicates(candidates, [])

			for (const result of filtered) {
				expect(typeof result.noveltyScore).toBe("number")
				expect(result.noveltyScore).toBeGreaterThanOrEqual(0)
				expect(result.noveltyScore).toBeLessThanOrEqual(1)
			}
		})

		it("should handle empty candidates", () => {
			const filtered = filterDuplicates([], [])
			expect(filtered).toEqual([])
		})

		it("should preserve additional properties", () => {
			const candidates = [
				{ id: "c1", embedding: createEmbedding(1), extra: "data" },
			]

			const filtered = filterDuplicates(candidates, [])

			expect(filtered[0]!.extra).toBe("data")
		})
	})

	describe("findMostSimilar", () => {
		it("should return most similar items sorted by similarity", () => {
			const target = createEmbedding(5)
			const existing: EmbeddingEntry[] = [
				{ id: "close", embedding: createSimilarEmbedding(target, 0.01) },
				{ id: "far", embedding: createEmbedding(100) },
				{ id: "medium", embedding: createSimilarEmbedding(target, 0.2) },
			]

			const similar = findMostSimilar(target, existing, 3)

			expect(similar[0]!.id).toBe("close")
			expect(similar[0]!.similarity).toBeGreaterThan(similar[1]!.similarity)
		})

		it("should respect limit parameter", () => {
			const target = createEmbedding(1)
			const existing = Array(10)
				.fill(0)
				.map((_, i) => ({
					id: `item-${i}`,
					embedding: createEmbedding(i + 2),
				}))

			const similar = findMostSimilar(target, existing, 3)

			expect(similar.length).toBe(3)
		})

		it("should filter by minimum similarity", () => {
			const target = createEmbedding(1)
			const existing: EmbeddingEntry[] = [
				{ id: "close", embedding: createSimilarEmbedding(target, 0.01) },
				{ id: "far", embedding: createEmbedding(100) },
			]

			const similar = findMostSimilar(target, existing, 10, 0.8)

			expect(similar.length).toBe(1)
			expect(similar[0]!.id).toBe("close")
		})

		it("should return empty for no matches above threshold", () => {
			const target = createEmbedding(1)
			const existing: EmbeddingEntry[] = [
				{ id: "far", embedding: createEmbedding(100) },
			]

			const similar = findMostSimilar(target, existing, 10, 0.99)

			expect(similar.length).toBe(0)
		})
	})

	describe("batchSimilarityCheck", () => {
		it("should check multiple embeddings at once", () => {
			const existing: EmbeddingEntry[] = [
				{ id: "existing-1", embedding: createEmbedding(1) },
			]

			const embeddings = [
				createSimilarEmbedding(createEmbedding(1), 0.01), // Duplicate
				createEmbedding(100), // Not duplicate
			]

			const results = batchSimilarityCheck(embeddings, existing, 0.9)

			expect(results.length).toBe(2)
			expect(results[0]!.isDuplicate).toBe(true)
			expect(results[0]!.index).toBe(0)
			expect(results[1]!.isDuplicate).toBe(false)
			expect(results[1]!.index).toBe(1)
		})

		it("should handle empty existing array", () => {
			const embeddings = [createEmbedding(1), createEmbedding(2)]

			const results = batchSimilarityCheck(embeddings, [], 0.9)

			expect(results.every((r) => r.isDuplicate === false)).toBe(true)
			expect(results.every((r) => r.maxSimilarity === 0)).toBe(true)
		})
	})

	describe("calculateDiversity", () => {
		it("should return 1 for single embedding", () => {
			const embeddings = [createEmbedding(1)]

			const diversity = calculateDiversity(embeddings)

			expect(diversity).toBe(1)
		})

		it("should return low diversity for similar embeddings", () => {
			const base = createEmbedding(1)
			const embeddings = [
				base,
				createSimilarEmbedding(base, 0.01),
				createSimilarEmbedding(base, 0.01),
			]

			const diversity = calculateDiversity(embeddings)

			expect(diversity).toBeLessThan(0.2) // Very similar = low diversity
		})

		it("should return high diversity for different embeddings", () => {
			const embeddings = [
				createEmbedding(1),
				createEmbedding(100),
				createEmbedding(200),
			]

			const diversity = calculateDiversity(embeddings)

			expect(diversity).toBeGreaterThan(0.5) // Different = higher diversity
		})

		it("should handle empty array", () => {
			const diversity = calculateDiversity([])

			expect(diversity).toBe(1) // Edge case: no items
		})
	})
})
