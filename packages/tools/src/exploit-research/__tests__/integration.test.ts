import { describe, it, expect, beforeAll, beforeEach, vi } from "vitest"
import { createExploitResearchMiddleware } from "../middleware"
import type { MiddlewareConfig, ToolCallContext } from "../middleware"

// These tests require a running Supermemory instance
// Skip in CI unless SUPERMEMORY_API_KEY is set
const runIntegration = !!process.env.SUPERMEMORY_API_KEY

describe.skipIf(!runIntegration)("Integration Tests", () => {
	const config: MiddlewareConfig = {
		apiKey: process.env.SUPERMEMORY_API_KEY!,
		baseUrl: process.env.SUPERMEMORY_BASE_URL,
		verbose: true,
	}

	let seasonId: string
	const protocolId = `test-protocol-${Date.now()}`

	describe("Season Lifecycle", () => {
		it("should create a new season", async () => {
			const response = await fetch(
				`${config.baseUrl}/v5/exploit-research/seasons`,
				{
					method: "POST",
					headers: {
						"Content-Type": "application/json",
						Authorization: `Bearer ${config.apiKey}`,
					},
					body: JSON.stringify({ protocolId }),
				},
			)

			expect(response.ok).toBe(true)
			const data = await response.json()
			expect(data.id).toMatch(new RegExp(`^${protocolId}:season-`))
			expect(data.status).toBe("active")
			seasonId = data.id
		})

		it("should store and retrieve artifacts", async () => {
			const middleware = createExploitResearchMiddleware(config)
			const context: ToolCallContext = {
				protocolId,
				seasonId,
				phase: "intake",
			}

			// Store an artifact
			const storeResponse = await fetch(
				`${config.baseUrl}/v5/exploit-research/artifacts`,
				{
					method: "POST",
					headers: {
						"Content-Type": "application/json",
						Authorization: `Bearer ${config.apiKey}`,
					},
					body: JSON.stringify({
						protocolId,
						seasonId,
						kind: "source",
						raw: "contract Test { function test() public {} }",
						summary: "Simple test contract with one function",
					}),
				},
			)

			expect(storeResponse.ok).toBe(true)
			const stored = await storeResponse.json()
			expect(stored.id).toBeDefined()

			// Retrieve it
			const retrieveResponse = await fetch(
				`${config.baseUrl}/v5/exploit-research/retrieve`,
				{
					method: "POST",
					headers: {
						"Content-Type": "application/json",
						Authorization: `Bearer ${config.apiKey}`,
					},
					body: JSON.stringify({
						protocolId,
						seasonId,
						query: "test contract function",
						limit: 5,
					}),
				},
			)

			expect(retrieveResponse.ok).toBe(true)
			const retrieved = await retrieveResponse.json()
			expect(retrieved.results.length).toBeGreaterThan(0)
			expect(retrieved.results[0].summary).toContain("test")
		})

		it("should enforce protocol isolation", async () => {
			// Try to retrieve from different protocol
			const response = await fetch(
				`${config.baseUrl}/v5/exploit-research/retrieve`,
				{
					method: "POST",
					headers: {
						"Content-Type": "application/json",
						Authorization: `Bearer ${config.apiKey}`,
					},
					body: JSON.stringify({
						protocolId: "different-protocol",
						seasonId,
						query: "test",
						limit: 5,
					}),
				},
			)

			// Should return empty or error
			const data = await response.json()
			expect(data.results?.length || 0).toBe(0)
		})

		it("should close season and freeze writes", async () => {
			// Close the season
			const closeResponse = await fetch(
				`${config.baseUrl}/v5/exploit-research/seasons/${seasonId}/close`,
				{
					method: "POST",
					headers: {
						"Content-Type": "application/json",
						Authorization: `Bearer ${config.apiKey}`,
					},
					body: JSON.stringify({ protocolId }),
				},
			)

			expect(closeResponse.ok).toBe(true)

			// Try to write to closed season
			const writeResponse = await fetch(
				`${config.baseUrl}/v5/exploit-research/artifacts`,
				{
					method: "POST",
					headers: {
						"Content-Type": "application/json",
						Authorization: `Bearer ${config.apiKey}`,
					},
					body: JSON.stringify({
						protocolId,
						seasonId,
						kind: "source",
						raw: "should fail",
					}),
				},
			)

			expect(writeResponse.ok).toBe(false)
			expect(writeResponse.status).toBe(403)
		})
	})

	describe("Dedup Workflow", () => {
		let newSeasonId: string

		beforeAll(async () => {
			// Create a fresh season for dedup tests
			const response = await fetch(
				`${config.baseUrl}/v5/exploit-research/seasons`,
				{
					method: "POST",
					headers: {
						"Content-Type": "application/json",
						Authorization: `Bearer ${config.apiKey}`,
					},
					body: JSON.stringify({ protocolId }),
				},
			)
			const data = await response.json()
			newSeasonId = data.id
		})

		it("should detect duplicate hypotheses", async () => {
			const hypothesis =
				"Flash loan attack on the swap function to drain liquidity"

			// Store first hypothesis
			await fetch(`${config.baseUrl}/v5/exploit-research/artifacts`, {
				method: "POST",
				headers: {
					"Content-Type": "application/json",
					Authorization: `Bearer ${config.apiKey}`,
				},
				body: JSON.stringify({
					protocolId,
					seasonId: newSeasonId,
					kind: "hypothesis",
					raw: hypothesis,
					summary: hypothesis,
				}),
			})

			// Wait for embedding
			await new Promise((r) => setTimeout(r, 1000))

			// Check for duplicate
			const similarResponse = await fetch(
				`${config.baseUrl}/v5/exploit-research/similar`,
				{
					method: "POST",
					headers: {
						"Content-Type": "application/json",
						Authorization: `Bearer ${config.apiKey}`,
					},
					body: JSON.stringify({
						protocolId,
						seasonId: newSeasonId,
						kind: "hypothesis",
						text: "Flash loan exploit targeting swap to remove liquidity",
						threshold: 0.8,
					}),
				},
			)

			expect(similarResponse.ok).toBe(true)
			const similar = await similarResponse.json()
			expect(similar.isDuplicate).toBe(true)
			expect(similar.maxSimilarity).toBeGreaterThan(0.8)
		})

		it("should allow novel hypotheses", async () => {
			const novelHypothesis = "Oracle manipulation via Chainlink price feed"

			const similarResponse = await fetch(
				`${config.baseUrl}/v5/exploit-research/similar`,
				{
					method: "POST",
					headers: {
						"Content-Type": "application/json",
						Authorization: `Bearer ${config.apiKey}`,
					},
					body: JSON.stringify({
						protocolId,
						seasonId: newSeasonId,
						kind: "hypothesis",
						text: novelHypothesis,
						threshold: 0.8,
					}),
				},
			)

			expect(similarResponse.ok).toBe(true)
			const similar = await similarResponse.json()
			expect(similar.isDuplicate).toBe(false)
		})
	})

	describe("Feedback Routing", () => {
		let testSeasonId: string
		let pathId: string
		let testId: string

		beforeAll(async () => {
			// Create season and entities for feedback test
			const seasonResponse = await fetch(
				`${config.baseUrl}/v5/exploit-research/seasons`,
				{
					method: "POST",
					headers: {
						"Content-Type": "application/json",
						Authorization: `Bearer ${config.apiKey}`,
					},
					body: JSON.stringify({ protocolId }),
				},
			)
			testSeasonId = (await seasonResponse.json()).id

			// Create a path
			const pathResponse = await fetch(
				`${config.baseUrl}/v5/exploit-research/artifacts`,
				{
					method: "POST",
					headers: {
						"Content-Type": "application/json",
						Authorization: `Bearer ${config.apiKey}`,
					},
					body: JSON.stringify({
						protocolId,
						seasonId: testSeasonId,
						kind: "path",
						raw: JSON.stringify({
							violatedInvariantId: "inv-test",
							steps: [{ contract: "Pool", function: "swap" }],
							confidence: 0.7,
						}),
					}),
				},
			)
			pathId = (await pathResponse.json()).id

			// Create a test
			const testResponse = await fetch(
				`${config.baseUrl}/v5/exploit-research/artifacts`,
				{
					method: "POST",
					headers: {
						"Content-Type": "application/json",
						Authorization: `Bearer ${config.apiKey}`,
					},
					body: JSON.stringify({
						protocolId,
						seasonId: testSeasonId,
						kind: "test",
						raw: "test_code",
						metadata: { scenarioId: "scenario-test" },
					}),
				},
			)
			testId = (await testResponse.json()).id
		})

		it("should route feedback and update linked entities", async () => {
			const feedbackResponse = await fetch(
				`${config.baseUrl}/v5/exploit-research/feedback`,
				{
					method: "POST",
					headers: {
						"Content-Type": "application/json",
						Authorization: `Bearer ${config.apiKey}`,
					},
					body: JSON.stringify({
						protocolId,
						seasonId: testSeasonId,
						testId,
						status: "pass",
						profit: 75000,
						linkedPathId: pathId,
						forgeLogsContent: "[PASS] testExploit (2.1s)\nProfit: 75000 USDC",
					}),
				},
			)

			expect(feedbackResponse.ok).toBe(true)
			const feedback = await feedbackResponse.json()
			expect(feedback.updatedEntities).toBeDefined()
			expect(feedback.updatedEntities.length).toBeGreaterThan(0)

			// Verify path was updated
			const pathUpdated = feedback.updatedEntities.find(
				(e: any) => e.id === pathId,
			)
			expect(pathUpdated).toBeDefined()
			expect(pathUpdated.field).toBe("confirmedCount")
		})
	})

	describe("Snapshot & Restore", () => {
		let snapshotSeasonId: string
		let snapshotId: string

		beforeAll(async () => {
			// Create season with some content
			const seasonResponse = await fetch(
				`${config.baseUrl}/v5/exploit-research/seasons`,
				{
					method: "POST",
					headers: {
						"Content-Type": "application/json",
						Authorization: `Bearer ${config.apiKey}`,
					},
					body: JSON.stringify({ protocolId }),
				},
			)
			snapshotSeasonId = (await seasonResponse.json()).id

			// Add some artifacts
			for (let i = 0; i < 3; i++) {
				await fetch(`${config.baseUrl}/v5/exploit-research/artifacts`, {
					method: "POST",
					headers: {
						"Content-Type": "application/json",
						Authorization: `Bearer ${config.apiKey}`,
					},
					body: JSON.stringify({
						protocolId,
						seasonId: snapshotSeasonId,
						kind: "invariant",
						raw: `invariant_${i}`,
						summary: `Test invariant ${i}`,
					}),
				})
			}
		})

		it("should create snapshot", async () => {
			const response = await fetch(
				`${config.baseUrl}/v5/exploit-research/snapshot`,
				{
					method: "POST",
					headers: {
						"Content-Type": "application/json",
						Authorization: `Bearer ${config.apiKey}`,
					},
					body: JSON.stringify({
						protocolId,
						seasonId: snapshotSeasonId,
					}),
				},
			)

			expect(response.ok).toBe(true)
			const snapshot = await response.json()
			expect(snapshot.id).toBeDefined()
			snapshotId = snapshot.id
		})

		it("should restore from snapshot", async () => {
			const response = await fetch(
				`${config.baseUrl}/v5/exploit-research/restore`,
				{
					method: "POST",
					headers: {
						"Content-Type": "application/json",
						Authorization: `Bearer ${config.apiKey}`,
					},
					body: JSON.stringify({
						protocolId,
						snapshotId,
					}),
				},
			)

			expect(response.ok).toBe(true)
			const restored = await response.json()
			expect(restored.success).toBe(true)
			expect(restored.restoredEntities.invariants).toBe(3)
		})
	})
})

// Unit tests that don't require a live API
describe("Middleware Unit Tests", () => {
	const mockFetch = vi.fn()

	beforeAll(() => {
		global.fetch = mockFetch as any
	})

	const config: MiddlewareConfig = {
		apiKey: "test-key",
		baseUrl: "https://api.test.com",
		verbose: false,
	}

	const context: ToolCallContext = {
		protocolId: "test-protocol",
		seasonId: "test-season",
		phase: "invariant",
	}

	describe("Error Handling", () => {
		beforeEach(() => {
			mockFetch.mockReset()
		})

		it("should handle network errors in wrapToolExecutor", async () => {
			mockFetch.mockRejectedValue(new Error("Network error"))

			const middleware = createExploitResearchMiddleware(config)
			const mockExecutor = vi.fn().mockResolvedValue("result")

			const wrapped = middleware.wrapToolExecutor(
				"test_tool",
				"source",
				mockExecutor,
			)

			// Should still work even if storage fails (fire and forget)
			const result = await wrapped({}, context)
			expect(result).toBe("result")
		})

		it("should propagate executor errors", async () => {
			mockFetch.mockResolvedValue({
				ok: true,
				json: async () => ({ id: "event-123" }),
			})

			const middleware = createExploitResearchMiddleware(config)
			const mockExecutor = vi.fn().mockRejectedValue(new Error("Executor failed"))

			const wrapped = middleware.wrapToolExecutor(
				"test_tool",
				"source",
				mockExecutor,
			)

			await expect(wrapped({}, context)).rejects.toThrow("Executor failed")
		})
	})

	describe("Default Configuration", () => {
		beforeEach(() => {
			mockFetch.mockReset()
		})

		it("should use default base URL when not provided", async () => {
			mockFetch.mockResolvedValue({
				ok: true,
				json: async () => ({ id: "event-123" }),
			})

			const configWithoutBase: MiddlewareConfig = {
				apiKey: "test-key",
				verbose: false,
			}

			const middleware = createExploitResearchMiddleware(configWithoutBase)
			const mockExecutor = vi.fn().mockResolvedValue("result")

			const wrapped = middleware.wrapToolExecutor(
				"test_tool",
				"source",
				mockExecutor,
			)

			await wrapped({}, context)

			// Wait for the fire-and-forget storage call to be made
			await new Promise(resolve => setTimeout(resolve, 10))

			expect(mockFetch).toHaveBeenCalled()
			const fetchCall = mockFetch.mock.calls[0]!
			expect(fetchCall[0]).toContain("https://api.supermemory.com")
		})
	})
})
