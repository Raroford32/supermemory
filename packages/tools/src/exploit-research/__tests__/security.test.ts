import { describe, it, expect } from "vitest"
import {
	redactSecrets,
	containsSecrets,
	checkSensitivity,
	sanitizeContent,
	processArtifactForSecurity,
} from "../security"

describe("Security Module", () => {
	describe("redactSecrets", () => {
		it("should redact Infura RPC URLs", () => {
			const content =
				"RPC_URL=https://mainnet.infura.io/v3/abc123def456789012345678901234ab"
			const result = redactSecrets(content)

			expect(result.redacted).toContain("[REDACTED_INFURA_KEY]")
			expect(result.redacted).not.toContain("abc123def456789012345678901234ab")
			expect(result.redactedCount).toBeGreaterThan(0)
			expect(result.redactedTypes).toContain("infura_rpc")
		})

		it("should redact Alchemy RPC URLs", () => {
			const content =
				"const rpc = 'https://eth-mainnet.g.alchemy.com/v2/abc123def456789012345678901234xy'"
			const result = redactSecrets(content)

			expect(result.redacted).toContain("[REDACTED_ALCHEMY_KEY]")
			expect(result.redactedCount).toBeGreaterThan(0)
		})

		it("should redact private keys", () => {
			const content =
				"PRIVATE_KEY=0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890"
			const result = redactSecrets(content)

			expect(result.redacted).toContain("[REDACTED_PRIVATE_KEY]")
			expect(result.redactedCount).toBeGreaterThan(0)
		})

		it("should redact Bearer tokens", () => {
			// Use a non-JWT bearer token
			const content =
				"Authorization: Bearer abc123def456xyz789012345tokenabc"
			const result = redactSecrets(content)

			expect(result.redacted).toContain("[REDACTED_TOKEN]")
			expect(result.redactedCount).toBeGreaterThan(0)
		})

		it("should redact JWT tokens", () => {
			// JWT tokens should be redacted when found in content
			const content =
				"The auth response was eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.dozjgNryP4J3jVmNHl0w5N_XgL0n3I9PlFUP0THsR8U"
			const result = redactSecrets(content)

			expect(result.redacted).toContain("[REDACTED_JWT]")
			expect(result.redactedTypes).toContain("jwt")
		})

		it("should redact AWS credentials", () => {
			const content = `
				AWS_ACCESS_KEY_ID=AKIAIOSFODNN7EXAMPLE
				AWS_SECRET_ACCESS_KEY=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
			`
			const result = redactSecrets(content)

			expect(result.redacted).toContain("[REDACTED_AWS_ACCESS_KEY]")
			expect(result.redacted).toContain("[REDACTED_AWS_SECRET_KEY]")
		})

		it("should redact Etherscan API keys", () => {
			const content =
				"etherscan_api_key=ABCDEFGHIJKLMNOPQRSTUVWXYZ12345678"
			const result = redactSecrets(content)

			// Should be redacted (either as etherscan key or generic)
			expect(result.redacted).not.toContain("ABCDEFGHIJKLMNOPQRSTUVWXYZ12345678")
			expect(result.redactedCount).toBeGreaterThan(0)
		})

		it("should redact generic secrets", () => {
			const content = "SECRET=mysupersecretvalue123"
			const result = redactSecrets(content)

			expect(result.redacted).toContain("[REDACTED_SECRET]")
		})

		it("should not modify content without secrets", () => {
			const content = "This is normal content without any secrets."
			const result = redactSecrets(content)

			expect(result.redacted).toBe(content)
			expect(result.redactedCount).toBe(0)
			expect(result.redactedTypes).toHaveLength(0)
		})

		it("should handle multiple secrets in one content", () => {
			const content = `
				INFURA_URL=https://mainnet.infura.io/v3/abc123def456789012345678901234ab
				PRIVATE_KEY=0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890
			`
			const result = redactSecrets(content)

			expect(result.redactedCount).toBeGreaterThanOrEqual(2)
			expect(result.redactedTypes.length).toBeGreaterThanOrEqual(2)
		})
	})

	describe("containsSecrets", () => {
		it("should return true for content with secrets", () => {
			expect(
				containsSecrets(
					"https://mainnet.infura.io/v3/abc123def456789012345678901234ab",
				),
			).toBe(true)
		})

		it("should return false for content without secrets", () => {
			expect(containsSecrets("Normal text without secrets")).toBe(false)
		})
	})

	describe("checkSensitivity", () => {
		it("should detect credential-related content", () => {
			const content = "The username and password are stored in config"
			const result = checkSensitivity(content)

			expect(result.isSensitive).toBe(true)
			expect(result.types).toContain("credentials")
		})

		it("should detect private key indicators", () => {
			const content = "-----BEGIN PRIVATE KEY-----"
			const result = checkSensitivity(content)

			expect(result.isSensitive).toBe(true)
			expect(result.types).toContain("private_key")
		})

		it("should detect internal paths", () => {
			const content = "File located at /home/user/project/config.json"
			const result = checkSensitivity(content)

			expect(result.isSensitive).toBe(true)
			expect(result.types).toContain("internal_paths")
		})

		it("should detect database connection strings", () => {
			const content = "mongodb://admin:password@localhost:27017"
			const result = checkSensitivity(content)

			expect(result.isSensitive).toBe(true)
			expect(result.types).toContain("database_credentials")
		})

		it("should return not sensitive for clean content", () => {
			const content = "This is a clean contract function"
			const result = checkSensitivity(content)

			expect(result.isSensitive).toBe(false)
			expect(result.types).toHaveLength(0)
		})
	})

	describe("sanitizeContent", () => {
		it("should redact secrets by default", () => {
			const content =
				"RPC: https://mainnet.infura.io/v3/abc123def456789012345678901234ab"
			const result = sanitizeContent(content)

			expect(result.wasModified).toBe(true)
			expect(result.content).toContain("[REDACTED_INFURA_KEY]")
		})

		it("should remove internal paths by default", () => {
			const content = "Path: /home/user/project/file.txt"
			const result = sanitizeContent(content)

			expect(result.wasModified).toBe(true)
			expect(result.content).toContain("[INTERNAL_PATH]")
			expect(result.content).not.toContain("/home/user")
		})

		it("should truncate long content when maxLength is set", () => {
			const content = "x".repeat(1000)
			const result = sanitizeContent(content, { maxLength: 100 })

			expect(result.wasModified).toBe(true)
			expect(result.content.length).toBeLessThanOrEqual(120) // 100 + truncation message
			expect(result.content).toContain("[TRUNCATED]")
		})

		it("should respect option to skip secret redaction", () => {
			const content =
				"RPC: https://mainnet.infura.io/v3/abc123def456789012345678901234ab"
			const result = sanitizeContent(content, { redactSecrets: false })

			expect(result.content).toContain("abc123def456789012345678901234ab")
		})

		it("should respect option to skip internal path removal", () => {
			const content = "Path: /home/user/project/file.txt"
			const result = sanitizeContent(content, { removeInternalPaths: false })

			expect(result.content).toContain("/home/user")
		})

		it("should return sensitivity check results", () => {
			const content = "Password: mysecret"
			const result = sanitizeContent(content)

			expect(result.sensitivity).toBeDefined()
			expect(result.sensitivity.isSensitive).toBe(true)
		})
	})

	describe("processArtifactForSecurity", () => {
		it("should process artifact and return security metadata", () => {
			const content = `
				RPC_URL=https://mainnet.infura.io/v3/abc123def456789012345678901234ab
				Path: /home/user/project
			`
			const result = processArtifactForSecurity(content)

			expect(result.securityMetadata.wasRedacted).toBe(true)
			expect(result.securityMetadata.sanitizedAt).toBeInstanceOf(Date)
			expect(result.content).toContain("[REDACTED_INFURA_KEY]")
			expect(result.content).toContain("[INTERNAL_PATH]")
		})

		it("should mark artifact as sensitive when appropriate", () => {
			const content = "The password for the wallet is stored in config"
			const result = processArtifactForSecurity(content)

			expect(result.securityMetadata.isSensitive).toBe(true)
			expect(result.securityMetadata.sensitivityTypes).toContain("credentials")
		})

		it("should not mark clean content as sensitive", () => {
			const content = "function swap(uint amount) external"
			const result = processArtifactForSecurity(content)

			expect(result.securityMetadata.isSensitive).toBe(false)
			expect(result.securityMetadata.wasRedacted).toBe(false)
		})

		it("should respect options passed to it", () => {
			// Use long content without secrets so truncation applies
			const content = "x".repeat(200)
			const result = processArtifactForSecurity(content, { maxLength: 100 })

			expect(result.content).toContain("[TRUNCATED]")
			expect(result.content.length).toBeLessThanOrEqual(120)
		})
	})
})
