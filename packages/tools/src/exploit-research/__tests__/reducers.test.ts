import { describe, it, expect } from "vitest"
import {
	reduceSourceCode,
	reduceABI,
	reduceGraph,
	reduceInvariants,
	reducePath,
	reduceForgeLogs,
	reduceAddressList,
	reduceGeneric,
	reduceByKind,
} from "../reducers"

describe("Reducers", () => {
	describe("reduceSourceCode", () => {
		it("should extract function signatures", () => {
			const source = `
        contract Pool {
          mapping(address => uint256) public balances;
          uint256 public totalSupply;

          function deposit(uint256 amount) external {
            require(amount > 0, "Invalid amount");
            balances[msg.sender] += amount;
          }

          function withdraw(uint256 amount) external {
            require(balances[msg.sender] >= amount, "Insufficient");
            balances[msg.sender] -= amount;
          }
        }
      `
			const result = reduceSourceCode(source)

			expect(result.summary).toContain("deposit")
			expect(result.summary).toContain("withdraw")
			expect(result.summary).toContain("State Variables")
			expect(result.summary).toContain("Security Checks")
			expect(result.extractedMetadata.functionCount).toBe(2)
			expect(result.extractedMetadata.requireCount).toBe(2)
			expect(result.shouldStoreRaw).toBe(true)
		})

		it("should extract modifiers", () => {
			const source = `
        contract Ownable {
          modifier onlyOwner() {
            require(msg.sender == owner, "Not owner");
            _;
          }

          modifier nonReentrant() {
            require(!locked, "Reentrant");
            locked = true;
            _;
            locked = false;
          }

          function doSomething() external onlyOwner {
          }
        }
      `
			const result = reduceSourceCode(source)

			expect(result.summary).toContain("onlyOwner")
			expect(result.summary).toContain("nonReentrant")
			expect(result.extractedMetadata.modifierCount).toBe(2)
		})

		it("should extract events", () => {
			const source = `
        contract Token {
          event Transfer(address indexed from, address indexed to, uint256 value);
          event Approval(address indexed owner, address indexed spender, uint256 value);

          function transfer(address to, uint256 value) public {
            emit Transfer(msg.sender, to, value);
          }
        }
      `
			const result = reduceSourceCode(source)

			expect(result.summary).toContain("Transfer")
			expect(result.summary).toContain("Approval")
			expect(result.extractedMetadata.eventCount).toBe(2)
		})

		it("should limit output for large contracts", () => {
			const largeFunctions = Array(100)
				.fill(0)
				.map((_, i) => `function fn${i}(uint256 x) public { }`)
				.join("\n")
			const source = `contract Large { ${largeFunctions} }`
			const result = reduceSourceCode(source)

			expect(result.summary).toContain("... and")
			expect(result.summary.length).toBeLessThan(source.length)
		})

		it("should handle empty source", () => {
			const result = reduceSourceCode("")
			expect(result.summary).toContain("Contract Outline")
			expect(result.extractedMetadata.functionCount).toBe(0)
		})
	})

	describe("reduceABI", () => {
		it("should categorize functions correctly", () => {
			const abi = JSON.stringify([
				{
					type: "function",
					name: "deposit",
					stateMutability: "payable",
					inputs: [],
				},
				{
					type: "function",
					name: "withdraw",
					stateMutability: "nonpayable",
					inputs: [],
				},
				{
					type: "function",
					name: "balanceOf",
					stateMutability: "view",
					inputs: [{ type: "address", name: "account" }],
				},
				{ type: "event", name: "Transfer" },
				{ type: "error", name: "InsufficientBalance" },
			])
			const result = reduceABI(abi)

			expect(result.summary).toContain("Write Functions (2)")
			expect(result.summary).toContain("Read Functions (1)")
			expect(result.summary).toContain("Events (1)")
			expect(result.summary).toContain("Errors (1)")
			expect(result.extractedMetadata.writeFunctions).toBe(2)
			expect(result.extractedMetadata.readFunctions).toBe(1)
		})

		it("should handle invalid JSON gracefully", () => {
			const result = reduceABI("not valid json")
			expect(result.summary).toContain("Invalid ABI")
			expect(result.extractedMetadata.parseError).toBe(true)
		})

		it("should handle non-array JSON", () => {
			const result = reduceABI('{"type": "function"}')
			expect(result.summary).toContain("Invalid ABI")
			expect(result.extractedMetadata.parseError).toBe(true)
		})

		it("should format function inputs", () => {
			const abi = JSON.stringify([
				{
					type: "function",
					name: "swap",
					stateMutability: "nonpayable",
					inputs: [
						{ type: "address", name: "tokenIn" },
						{ type: "uint256", name: "amountIn" },
					],
				},
			])
			const result = reduceABI(abi)

			expect(result.summary).toContain("swap(address tokenIn, uint256 amountIn)")
		})
	})

	describe("reduceGraph", () => {
		it("should extract critical nodes", () => {
			const graph = JSON.stringify({
				nodes: [
					{
						contract: "Pool",
						function: "swap",
						holdsValue: true,
						risk: "high",
					},
					{ contract: "Pool", function: "deposit", holdsValue: true },
					{ contract: "Router", function: "route", isEntryPoint: true },
					{ contract: "Oracle", function: "getPrice", risk: "medium" },
				],
				edges: [
					{ from: "Router.route", to: "Pool.swap" },
					{ from: "Pool.swap", to: "Oracle.getPrice" },
				],
			})
			const result = reduceGraph(graph)

			expect(result.summary).toContain("Nodes: 4")
			expect(result.summary).toContain("Edges: 2")
			expect(result.summary).toContain("Critical Nodes")
			expect(result.extractedMetadata.nodeCount).toBe(4)
			expect(result.extractedMetadata.edgeCount).toBe(2)
		})

		it("should count unique contracts", () => {
			const graph = JSON.stringify({
				nodes: [
					{ contract: "Pool", function: "swap" },
					{ contract: "Pool", function: "deposit" },
					{ contract: "Router", function: "route" },
				],
				edges: [],
			})
			const result = reduceGraph(graph)

			expect(result.summary).toContain("Contracts: 2")
			expect(result.extractedMetadata.contractCount).toBe(2)
		})

		it("should handle invalid JSON", () => {
			const result = reduceGraph("invalid json")
			expect(result.summary).toContain("Graph parse error")
			expect(result.extractedMetadata.parseError).toBe(true)
		})

		it("should handle empty graph", () => {
			const result = reduceGraph(JSON.stringify({ nodes: [], edges: [] }))
			expect(result.extractedMetadata.nodeCount).toBe(0)
			expect(result.extractedMetadata.edgeCount).toBe(0)
		})
	})

	describe("reduceInvariants", () => {
		it("should group by category", () => {
			const invariants = JSON.stringify([
				{
					category: "arithmetic",
					formula: "x + y >= z",
					severity: "high",
					confidence: 0.9,
				},
				{
					category: "arithmetic",
					formula: "a * b == c",
					severity: "medium",
					confidence: 0.8,
				},
				{
					category: "access_control",
					formula: "onlyOwner",
					severity: "critical",
					confidence: 0.95,
				},
			])
			const result = reduceInvariants(invariants)

			expect(result.summary).toContain("arithmetic (2)")
			expect(result.summary).toContain("access_control (1)")
			expect(result.extractedMetadata.totalInvariants).toBe(3)
			expect((result.extractedMetadata.byCategory as any).arithmetic).toBe(2)
		})

		it("should handle non-array JSON", () => {
			const result = reduceInvariants('{"invariant": "test"}')
			expect(result.summary).toBe('{"invariant": "test"}')
		})

		it("should handle invalid JSON", () => {
			const result = reduceInvariants("not json")
			expect(result.summary).toBe("not json")
		})

		it("should handle missing confidence", () => {
			const invariants = JSON.stringify([
				{ category: "arithmetic", formula: "x > 0", severity: "high" },
			])
			const result = reduceInvariants(invariants)

			expect(result.summary).toContain("conf: 0%")
		})
	})

	describe("reducePath", () => {
		it("should format path with steps", () => {
			const path = JSON.stringify({
				violatedInvariantId: "inv-001",
				steps: [
					{ contract: "Pool", function: "flash", inputs: { amount0: "1000000" } },
					{ contract: "Pool", function: "swap", inputs: { zeroForOne: true } },
				],
				estimatedProfit: 50000,
				confidence: 0.8,
				assumptions: ["Sufficient liquidity"],
				preconditions: ["Block number > 18000000"],
			})
			const result = reducePath(path)

			expect(result.summary).toContain("Violates: inv-001")
			expect(result.summary).toContain("Confidence: 80%")
			expect(result.summary).toContain("$50,000")
			expect(result.summary).toContain("Steps (2)")
			expect(result.summary).toContain("Pool.flash")
			expect(result.summary).toContain("Pool.swap")
			expect(result.extractedMetadata.stepCount).toBe(2)
		})

		it("should handle missing optional fields", () => {
			const path = JSON.stringify({
				violatedInvariantId: "inv-001",
				steps: [],
			})
			const result = reducePath(path)

			expect(result.summary).toContain("Violates: inv-001")
			expect(result.summary).toContain("Confidence: 0%")
			expect(result.summary).toContain("Est. Profit: unknown")
		})

		it("should handle invalid JSON", () => {
			const result = reducePath("not json")
			expect(result.summary).toBe("not json")
		})
	})

	describe("reduceForgeLogs", () => {
		it("should extract test results", () => {
			const logs = `
        Running 3 tests for test/Exploit.t.sol
        [PASS] testFlashLoan (1.234s)
        [FAIL] testReentrancy (0.567s)
        [PASS] testOracle (2.345s)

        Error: Revert: insufficient liquidity
        Profit extracted: 50000 USDC
      `
			const result = reduceForgeLogs(logs)

			expect(result.summary).toContain("Total: 3")
			expect(result.summary).toContain("Passed: 2")
			expect(result.summary).toContain("Failed: 1")
			expect(result.summary).toContain("Reverts")
			expect(result.summary).toContain("Profits")
			expect(result.extractedMetadata.totalTests).toBe(3)
			expect(result.extractedMetadata.passed).toBe(2)
			expect(result.extractedMetadata.failed).toBe(1)
		})

		it("should handle logs without test results", () => {
			const logs = `
        Compiling contracts...
        No tests found
      `
			const result = reduceForgeLogs(logs)

			expect(result.extractedMetadata.totalTests).toBe(0)
		})

		it("should capture revert reasons", () => {
			const logs = `
        [FAIL] testExploit
        Revert: ERC20: transfer amount exceeds balance
        revert reason: STF
      `
			const result = reduceForgeLogs(logs)

			expect(result.extractedMetadata.revertCount).toBe(2)
			expect(result.summary).toContain("Revert")
		})

		it("should capture profit mentions", () => {
			const logs = `
        Profit: 100 ETH
        Total profit extracted: 50000 USDC
      `
			const result = reduceForgeLogs(logs)

			expect(result.extractedMetadata.profitMentions).toBe(2)
		})
	})

	describe("reduceAddressList", () => {
		it("should categorize addresses", () => {
			const addresses = JSON.stringify([
				{
					address: "0x1234567890abcdef1234567890abcdef12345678",
					category: "vault",
					name: "Main Vault",
					holdsValue: true,
				},
				{
					address: "0xabcdefabcdefabcdefabcdefabcdefabcdefabcd",
					category: "vault",
					name: "Secondary Vault",
					holdsValue: true,
				},
				{
					address: "0x9999999999999999999999999999999999999999",
					category: "router",
					name: "Router",
					holdsValue: false,
				},
			])
			const result = reduceAddressList(addresses)

			expect(result.summary).toContain("3 total")
			expect(result.summary).toContain("2 value-holding")
			expect(result.summary).toContain("vault (2)")
			expect(result.summary).toContain("router (1)")
			expect(result.summary).toContain("[VALUE]")
			expect(result.extractedMetadata.totalAddresses).toBe(3)
			expect(result.extractedMetadata.valueHolding).toBe(2)
		})

		it("should handle non-array JSON", () => {
			const result = reduceAddressList('{"address": "0x1234"}')
			expect(result.summary).toBe('{"address": "0x1234"}')
		})

		it("should handle invalid JSON", () => {
			const result = reduceAddressList("not json")
			expect(result.summary).toBe("not json")
		})
	})

	describe("reduceGeneric", () => {
		it("should truncate long content with markers", () => {
			const longContent = "x".repeat(5000)
			const result = reduceGeneric(longContent, 2000)

			expect(result.summary.length).toBeLessThan(longContent.length)
			expect(result.summary).toContain("chars omitted")
			expect(result.shouldStoreRaw).toBe(true)
		})

		it("should not truncate short content", () => {
			const shortContent = "short content"
			const result = reduceGeneric(shortContent, 2000)

			expect(result.summary).toBe(shortContent)
			expect(result.shouldStoreRaw).toBe(false)
		})

		it("should preserve original length in metadata", () => {
			const content = "x".repeat(5000)
			const result = reduceGeneric(content, 2000)

			expect(result.extractedMetadata.originalLength).toBe(5000)
		})

		it("should use default max length", () => {
			const content = "x".repeat(3000)
			const result = reduceGeneric(content)

			expect(result.summary.length).toBeLessThan(content.length)
			expect(result.shouldStoreRaw).toBe(true)
		})
	})

	describe("reduceByKind", () => {
		it("should dispatch to correct reducer", () => {
			const sourceResult = reduceByKind(
				"source",
				"function test() public {}",
			)
			expect(sourceResult.summary).toContain("Functions")

			const genericResult = reduceByKind("unknown", "some content")
			expect(genericResult.summary).toBe("some content")
		})

		it("should handle all artifact kinds", () => {
			const kinds = [
				{ kind: "source", content: "function test() {}" },
				{ kind: "abi", content: "[]" },
				{ kind: "graph", content: '{"nodes":[],"edges":[]}' },
				{ kind: "invariant", content: "[]" },
				{ kind: "path", content: '{"steps":[]}' },
				{ kind: "hypothesis", content: '{"steps":[]}' },
				{ kind: "forge_output", content: "test logs" },
				{ kind: "execution", content: "execution logs" },
				{ kind: "contract_outline", content: "function foo() {}" },
				{ kind: "tool_output", content: "tool output" },
			]

			for (const { kind, content } of kinds) {
				const result = reduceByKind(kind, content)
				expect(result.summary).toBeDefined()
				expect(typeof result.shouldStoreRaw).toBe("boolean")
			}
		})
	})
})
