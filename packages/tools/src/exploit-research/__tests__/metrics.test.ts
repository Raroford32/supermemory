import { describe, it, expect, beforeEach } from "vitest"
import { createMetricsCollector, MetricsCollector } from "../metrics"

describe("Metrics Module", () => {
	let collector: MetricsCollector

	beforeEach(() => {
		collector = createMetricsCollector("test-season", "test-protocol")
	})

	describe("createMetricsCollector", () => {
		it("should create a new metrics collector", () => {
			const c = createMetricsCollector("season-1", "protocol-1")
			expect(c).toBeInstanceOf(MetricsCollector)
		})

		it("should initialize with zero metrics", () => {
			const metrics = collector.getMetrics()
			expect(metrics.tokens.inputTokens).toBe(0)
			expect(metrics.retrieval.totalQueries).toBe(0)
			expect(metrics.dedup.totalChecks).toBe(0)
			expect(metrics.execution.totalTests).toBe(0)
		})

		it("should set season and protocol IDs", () => {
			const metrics = collector.getMetrics()
			expect(metrics.seasonId).toBe("test-season")
			expect(metrics.protocolId).toBe("test-protocol")
		})
	})

	describe("recordTokenUsage", () => {
		it("should track input and output tokens", () => {
			collector.recordTokenUsage({
				inputTokens: 100,
				outputTokens: 200,
				rawLength: 1000,
				reducedLength: 500,
			})

			const metrics = collector.getTokenMetrics()
			expect(metrics.inputTokens).toBe(100)
			expect(metrics.outputTokens).toBe(200)
		})

		it("should calculate tokens saved", () => {
			collector.recordTokenUsage({
				inputTokens: 100,
				outputTokens: 50,
				rawLength: 1000,
				reducedLength: 200,
			})

			const metrics = collector.getTokenMetrics()
			// Estimated: rawTokens = 250, reducedTokens = 50, saved = 200
			expect(metrics.tokensSaved).toBeGreaterThan(0)
		})

		it("should calculate reduction ratio", () => {
			collector.recordTokenUsage({
				inputTokens: 100,
				outputTokens: 50,
				rawLength: 1000,
				reducedLength: 200,
			})

			const metrics = collector.getTokenMetrics()
			expect(metrics.reductionRatio).toBeGreaterThan(0)
			expect(metrics.reductionRatio).toBeLessThanOrEqual(1)
		})

		it("should accumulate cost", () => {
			collector.recordTokenUsage({
				inputTokens: 100,
				outputTokens: 50,
				rawLength: 500,
				reducedLength: 200,
				costUsd: 0.01,
			})
			collector.recordTokenUsage({
				inputTokens: 100,
				outputTokens: 50,
				rawLength: 500,
				reducedLength: 200,
				costUsd: 0.02,
			})

			const metrics = collector.getTokenMetrics()
			expect(metrics.costUsd).toBe(0.03)
		})
	})

	describe("recordRetrievalQuery", () => {
		it("should track total queries", () => {
			collector.recordRetrievalQuery({ resultCount: 5, latencyMs: 100, success: true })
			collector.recordRetrievalQuery({ resultCount: 3, latencyMs: 150, success: true })

			const metrics = collector.getRetrievalMetrics()
			expect(metrics.totalQueries).toBe(2)
		})

		it("should track successful queries", () => {
			collector.recordRetrievalQuery({ resultCount: 5, latencyMs: 100, success: true })
			collector.recordRetrievalQuery({ resultCount: 0, latencyMs: 50, success: false })

			const metrics = collector.getRetrievalMetrics()
			expect(metrics.successfulQueries).toBe(1)
		})

		it("should calculate hit rate", () => {
			collector.recordRetrievalQuery({ resultCount: 5, latencyMs: 100, success: true })
			collector.recordRetrievalQuery({ resultCount: 0, latencyMs: 50, success: false })

			const metrics = collector.getRetrievalMetrics()
			expect(metrics.hitRate).toBe(0.5)
		})

		it("should calculate average result count", () => {
			collector.recordRetrievalQuery({ resultCount: 4, latencyMs: 100, success: true })
			collector.recordRetrievalQuery({ resultCount: 6, latencyMs: 150, success: true })

			const metrics = collector.getRetrievalMetrics()
			expect(metrics.averageResultCount).toBe(5)
		})

		it("should calculate average latency", () => {
			collector.recordRetrievalQuery({ resultCount: 5, latencyMs: 100, success: true })
			collector.recordRetrievalQuery({ resultCount: 5, latencyMs: 200, success: true })

			const metrics = collector.getRetrievalMetrics()
			expect(metrics.averageLatencyMs).toBe(150)
		})
	})

	describe("recordDedupCheck", () => {
		it("should track total checks", () => {
			collector.recordDedupCheck({ isDuplicate: false, noveltyScore: 0.8 })
			collector.recordDedupCheck({ isDuplicate: true, noveltyScore: 0.1 })

			const metrics = collector.getDedupMetrics()
			expect(metrics.totalChecks).toBe(2)
		})

		it("should track duplicates rejected", () => {
			collector.recordDedupCheck({ isDuplicate: false, noveltyScore: 0.8 })
			collector.recordDedupCheck({ isDuplicate: true, noveltyScore: 0.1 })
			collector.recordDedupCheck({ isDuplicate: true, noveltyScore: 0.05 })

			const metrics = collector.getDedupMetrics()
			expect(metrics.duplicatesRejected).toBe(2)
		})

		it("should calculate rejection rate", () => {
			collector.recordDedupCheck({ isDuplicate: false, noveltyScore: 0.8 })
			collector.recordDedupCheck({ isDuplicate: true, noveltyScore: 0.1 })

			const metrics = collector.getDedupMetrics()
			expect(metrics.rejectionRate).toBe(0.5)
		})

		it("should calculate average novelty score", () => {
			collector.recordDedupCheck({ isDuplicate: false, noveltyScore: 0.8 })
			collector.recordDedupCheck({ isDuplicate: false, noveltyScore: 0.6 })

			const metrics = collector.getDedupMetrics()
			expect(metrics.averageNoveltyScore).toBe(0.7)
		})

		it("should track novelty score distribution", () => {
			collector.recordDedupCheck({ isDuplicate: false, noveltyScore: 0.1 }) // low
			collector.recordDedupCheck({ isDuplicate: false, noveltyScore: 0.5 }) // medium
			collector.recordDedupCheck({ isDuplicate: false, noveltyScore: 0.9 }) // high

			const metrics = collector.getDedupMetrics()
			expect(metrics.noveltyScoreDistribution.low).toBe(1)
			expect(metrics.noveltyScoreDistribution.medium).toBe(1)
			expect(metrics.noveltyScoreDistribution.high).toBe(1)
		})
	})

	describe("phase tracking", () => {
		it("should start tracking a phase", () => {
			collector.startPhase("intake")

			const metrics = collector.getMetrics()
			expect(metrics.phases.intake).not.toBeNull()
			expect(metrics.phases.intake?.startedAt).toBeInstanceOf(Date)
		})

		it("should update phase progress", () => {
			collector.startPhase("graphing")
			collector.updatePhaseProgress("graphing", {
				coverage: 50,
				artifactsGenerated: 10,
				tokensUsed: 1000,
			})

			const metrics = collector.getMetrics()
			expect(metrics.phases.graphing?.coverage).toBe(50)
			expect(metrics.phases.graphing?.artifactsGenerated).toBe(10)
			expect(metrics.phases.graphing?.tokensUsed).toBe(1000)
		})

		it("should accumulate artifacts and tokens", () => {
			collector.startPhase("invariant")
			collector.updatePhaseProgress("invariant", { artifactsGenerated: 5 })
			collector.updatePhaseProgress("invariant", { artifactsGenerated: 3 })

			const metrics = collector.getMetrics()
			expect(metrics.phases.invariant?.artifactsGenerated).toBe(8)
		})

		it("should complete a phase", () => {
			collector.startPhase("violation")
			collector.completePhase("violation", 100)

			const metrics = collector.getMetrics()
			expect(metrics.phases.violation?.completedAt).toBeInstanceOf(Date)
			expect(metrics.phases.violation?.coverage).toBe(100)
		})

		it("should get phase coverage summary", () => {
			collector.startPhase("intake")
			collector.updatePhaseProgress("intake", { coverage: 100 })
			collector.startPhase("graphing")
			collector.updatePhaseProgress("graphing", { coverage: 50 })

			const coverage = collector.getPhaseCoverage()
			expect(coverage.intake).toBe(100)
			expect(coverage.graphing).toBe(50)
			expect(coverage.invariant).toBe(0)
		})
	})

	describe("recordExecution", () => {
		it("should track total tests", () => {
			collector.recordExecution({ status: "pass" })
			collector.recordExecution({ status: "fail" })

			const metrics = collector.getExecutionMetrics()
			expect(metrics.totalTests).toBe(2)
		})

		it("should track status counts", () => {
			collector.recordExecution({ status: "pass" })
			collector.recordExecution({ status: "pass" })
			collector.recordExecution({ status: "fail" })
			collector.recordExecution({ status: "flaky" })
			collector.recordExecution({ status: "inconclusive" })
			collector.recordExecution({ status: "error" })

			const metrics = collector.getExecutionMetrics()
			expect(metrics.passed).toBe(2)
			expect(metrics.failed).toBe(1)
			expect(metrics.flaky).toBe(1)
			expect(metrics.inconclusive).toBe(1)
			expect(metrics.error).toBe(1)
		})

		it("should calculate pass rate", () => {
			collector.recordExecution({ status: "pass" })
			collector.recordExecution({ status: "pass" })
			collector.recordExecution({ status: "fail" })
			collector.recordExecution({ status: "fail" })

			const metrics = collector.getExecutionMetrics()
			expect(metrics.passRate).toBe(0.5)
		})

		it("should track profit", () => {
			collector.recordExecution({ status: "pass", profit: 10000 })
			collector.recordExecution({ status: "pass", profit: 5000 })
			collector.recordExecution({ status: "fail", profit: 0 })

			const metrics = collector.getExecutionMetrics()
			expect(metrics.profitableCount).toBe(2)
			expect(metrics.totalProfit).toBe(15000)
			expect(metrics.averageProfit).toBe(7500)
		})

		it("should not count zero or negative profit", () => {
			collector.recordExecution({ status: "pass", profit: 0 })
			collector.recordExecution({ status: "pass", profit: -100 })

			const metrics = collector.getExecutionMetrics()
			expect(metrics.profitableCount).toBe(0)
		})
	})

	describe("getSummaryReport", () => {
		it("should generate a summary report", () => {
			collector.recordTokenUsage({
				inputTokens: 1000,
				outputTokens: 500,
				rawLength: 4000,
				reducedLength: 2000,
				costUsd: 0.05,
			})
			collector.recordRetrievalQuery({ resultCount: 5, latencyMs: 100, success: true })
			collector.recordDedupCheck({ isDuplicate: false, noveltyScore: 0.8 })
			collector.recordExecution({ status: "pass", profit: 10000 })

			const report = collector.getSummaryReport()

			expect(report).toContain("Season Metrics Summary")
			expect(report).toContain("Token Usage")
			expect(report).toContain("Retrieval Performance")
			expect(report).toContain("Dedup Effectiveness")
			expect(report).toContain("Execution Results")
		})
	})

	describe("reset", () => {
		it("should reset all metrics to initial state", () => {
			collector.recordTokenUsage({
				inputTokens: 1000,
				outputTokens: 500,
				rawLength: 4000,
				reducedLength: 2000,
			})
			collector.recordRetrievalQuery({ resultCount: 5, latencyMs: 100, success: true })

			collector.reset()

			const metrics = collector.getMetrics()
			expect(metrics.tokens.inputTokens).toBe(0)
			expect(metrics.retrieval.totalQueries).toBe(0)
			expect(metrics.seasonId).toBe("test-season") // Should preserve IDs
			expect(metrics.protocolId).toBe("test-protocol")
		})
	})

	describe("serialization", () => {
		it("should export metrics as JSON", () => {
			collector.recordTokenUsage({
				inputTokens: 100,
				outputTokens: 50,
				rawLength: 400,
				reducedLength: 200,
			})

			const json = collector.toJSON()
			const parsed = JSON.parse(json)

			expect(parsed.seasonId).toBe("test-season")
			expect(parsed.tokens.inputTokens).toBe(100)
		})

		it("should import metrics from JSON", () => {
			const other = createMetricsCollector("other-season", "other-protocol")
			other.recordTokenUsage({
				inputTokens: 500,
				outputTokens: 250,
				rawLength: 2000,
				reducedLength: 1000,
			})

			const json = other.toJSON()

			collector.fromJSON(json)
			const metrics = collector.getMetrics()

			expect(metrics.seasonId).toBe("other-season")
			expect(metrics.tokens.inputTokens).toBe(500)
		})
	})
})
