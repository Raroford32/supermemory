/**
 * Comprehensive Debug & Verification Tests
 *
 * This file tests end-to-end workflows and verifies all components
 * work together correctly.
 */

import { describe, it, expect, beforeEach } from "vitest"

// Import all modules
import {
	// Schemas
	PhaseEnum,
	SeasonStatusEnum,
	ArtifactKindEnum,
	InvariantCategoryEnum,
	TestStatusEnum,
	ExploitRelationEnum,
	SeverityEnum,
	ProtocolSchema,
	SeasonSchema,
	ContractSchema,
	GraphSchema,
	InvariantSchema,
	PathSchema,
	ScenarioSchema,
	TestSchema,
	ExecutionSchema,
	ToolEventSchema,
	ArtifactSchema,
	QuestionSchema,
	EntityRelationSchema,
	FeedbackSchema,
	SeasonSnapshotSchema,
} from "@repo/validation/exploit-research-schemas"

import {
	LogEventRequestSchema,
	StoreArtifactRequestSchema,
	RetrieveRequestSchema,
	SimilarRequestSchema,
	LinkRequestSchema,
	RecordFeedbackRequestSchema,
	SnapshotRequestSchema,
	RestoreRequestSchema,
	CreateSeasonRequestSchema,
	CloseSeasonRequestSchema,
	ImportSummariesRequestSchema,
} from "@repo/validation/exploit-research-api"

import {
	reduceSourceCode,
	reduceABI,
	reduceGraph,
	reduceInvariants,
	reducePath,
	reduceForgeLogs,
	reduceAddressList,
	reduceGeneric,
	reduceByKind,
} from "../reducers"

import {
	cosineSimilarity,
	checkDuplicate,
	calculateNoveltyScore,
	filterDuplicates,
	findMostSimilar,
	batchSimilarityCheck,
	calculateDiversity,
} from "../dedup"

import {
	redactSecrets,
	containsSecrets,
	checkSensitivity,
	sanitizeContent,
	processArtifactForSecurity,
} from "../security"

import { createMetricsCollector } from "../metrics"

describe("End-to-End Verification", () => {
	describe("1. Schema Validation Chain", () => {
		it("should validate complete Protocol → Season → Contract → Graph flow", () => {
			// Create a valid protocol
			const protocol = ProtocolSchema.parse({
				id: "uniswap-v3",
				name: "Uniswap V3",
				chains: ["ethereum", "arbitrum"],
				type: "dex",
				valueContracts: ["0x1234..."],
				criticalFunctions: [
					{
						contract: "Pool",
						function: "swap",
						signature: "swap(address,bool,int256,uint160,bytes)",
						risk: "critical",
					},
				],
				seasonIds: [],
				createdAt: new Date(),
				updatedAt: new Date(),
			})
			expect(protocol.id).toBe("uniswap-v3")

			// Create a valid season
			const season = SeasonSchema.parse({
				id: "uniswap-v3:season-20241205-abc123",
				protocolId: protocol.id,
				status: "active",
				startedAt: new Date(),
				coverage: {
					contractsAnalyzed: 0,
					functionsAnalyzed: 0,
					invariantsGenerated: 0,
					pathsExplored: 0,
					scenariosGenerated: 0,
					testsRun: 0,
					testsPassed: 0,
					testsFailed: 0,
					profitableExploits: 0,
				},
				activePhases: ["intake"],
				createdAt: new Date(),
				updatedAt: new Date(),
			})
			expect(season.protocolId).toBe(protocol.id)

			// Create a valid contract
			const contract = ContractSchema.parse({
				id: "contract-1",
				protocolId: protocol.id,
				seasonId: season.id,
				address: "0x1234567890abcdef1234567890abcdef12345678",
				chain: "ethereum",
				name: "UniswapV3Pool",
				holdsValue: true,
				role: "pool",
				createdAt: new Date(),
				updatedAt: new Date(),
			})
			expect(contract.seasonId).toBe(season.id)

			// Create a valid graph
			const graph = GraphSchema.parse({
				id: "graph-1",
				protocolId: protocol.id,
				seasonId: season.id,
				nodeCount: 50,
				edgeCount: 120,
				graphHash: "sha256-abc123",
				contractsCovered: [contract.id],
				coverage: 85,
				createdAt: new Date(),
				updatedAt: new Date(),
			})
			expect(graph.contractsCovered).toContain(contract.id)
		})

		it("should validate Invariant → Path → Scenario → Test → Execution flow", () => {
			const protocolId = "test-protocol"
			const seasonId = "test-protocol:season-20241205-xyz"

			// Create invariant
			const invariant = InvariantSchema.parse({
				id: "inv-arithmetic-001",
				protocolId,
				seasonId,
				category: "arithmetic",
				formula: "reserve0 * reserve1 >= k",
				description: "Constant product invariant",
				variables: ["reserve0", "reserve1", "k"],
				severity: "critical",
				confidence: 0.95,
				createdAt: new Date(),
				updatedAt: new Date(),
			})
			expect(invariant.category).toBe("arithmetic")

			// Create path that violates invariant
			const path = PathSchema.parse({
				id: "path-001",
				protocolId,
				seasonId,
				violatedInvariantId: invariant.id,
				steps: [
					{ contract: "Pool", function: "flashLoan", inputs: { amount: 1000000 } },
					{ contract: "Pool", function: "swap", inputs: { amount: 500000 } },
				],
				estimatedProfit: 50000,
				confidence: 0.8,
				complexity: 5,
				assumptions: ["Flash loan available"],
				preconditions: ["Pool has liquidity > 1M"],
				createdAt: new Date(),
				updatedAt: new Date(),
			})
			expect(path.violatedInvariantId).toBe(invariant.id)

			// Create scenario from path
			const scenario = ScenarioSchema.parse({
				id: "scenario-001",
				protocolId,
				seasonId,
				derivedFromPathId: path.id,
				grossProfit: 50000,
				netProfit: 45000,
				gasCosts: 5000,
				contractsInvolved: ["Pool", "Router"],
				confidence: 0.75,
				complexity: 5,
				createdAt: new Date(),
				updatedAt: new Date(),
			})
			expect(scenario.derivedFromPathId).toBe(path.id)

			// Create test for scenario
			const test = TestSchema.parse({
				id: "test-001",
				protocolId,
				seasonId,
				scenarioId: scenario.id,
				codeHash: "sha256-test-code",
				status: "pending",
				forkRpc: "https://eth-mainnet.alchemyapi.io/v2/xxx",
				forkBlock: 18500000,
				createdAt: new Date(),
				updatedAt: new Date(),
			})
			expect(test.scenarioId).toBe(scenario.id)

			// Create execution result
			const execution = ExecutionSchema.parse({
				id: "exec-001",
				protocolId,
				seasonId,
				testId: test.id,
				status: "pass",
				profit: 45000,
				forkRpc: "https://eth-mainnet.alchemyapi.io/v2/xxx",
				forkBlock: 18500000,
				gasUsed: 250000,
				executionTime: 2500,
				createdAt: new Date(),
			})
			expect(execution.testId).toBe(test.id)
			expect(execution.profit).toBe(45000)
		})

		it("should validate Artifact with security fields", () => {
			const artifact = ArtifactSchema.parse({
				id: "artifact-001",
				protocolId: "test",
				seasonId: "test:season-001",
				kind: "source",
				raw: "contract Test {}",
				summary: "Simple test contract",
				isSensitive: false,
				wasRedacted: false,
				createdAt: new Date(),
				updatedAt: new Date(),
			})
			expect(artifact.isSensitive).toBe(false)

			const sensitiveArtifact = ArtifactSchema.parse({
				id: "artifact-002",
				protocolId: "test",
				seasonId: "test:season-001",
				kind: "log",
				raw: "[REDACTED]",
				isSensitive: true,
				sensitivityTypes: ["credentials", "private_key"],
				wasRedacted: true,
				createdAt: new Date(),
				updatedAt: new Date(),
			})
			expect(sensitiveArtifact.isSensitive).toBe(true)
			expect(sensitiveArtifact.sensitivityTypes).toContain("credentials")
		})
	})

	describe("2. API Schema Validation", () => {
		it("should validate all 7 required APIs", () => {
			// 1. log_event
			const logEvent = LogEventRequestSchema.parse({
				protocolId: "uniswap-v3",
				seasonId: "uniswap-v3:season-20241205-abc",
				phase: "invariant",
				toolName: "etherscan_fetch",
				toolCallId: "call-123",
				success: true,
				duration: 1500,
			})
			expect(logEvent.phase).toBe("invariant")

			// 2. store_artifact
			const storeArtifact = StoreArtifactRequestSchema.parse({
				protocolId: "uniswap-v3",
				seasonId: "uniswap-v3:season-20241205-abc",
				kind: "source",
				raw: "contract Code {}",
				summary: "Contract source",
			})
			expect(storeArtifact.kind).toBe("source")

			// 3. retrieve
			const retrieve = RetrieveRequestSchema.parse({
				protocolId: "uniswap-v3",
				seasonId: "uniswap-v3:season-20241205-abc",
				query: "flash loan vulnerability",
				filters: { phase: "violation", kind: "path" },
				limit: 10,
			})
			expect(retrieve.query).toBe("flash loan vulnerability")

			// 4. similar
			const similar = SimilarRequestSchema.parse({
				protocolId: "uniswap-v3",
				seasonId: "uniswap-v3:season-20241205-abc",
				kind: "hypothesis",
				text: "Flash loan attack on swap",
				threshold: 0.85,
			})
			expect(similar.threshold).toBe(0.85)

			// 5. link
			const link = LinkRequestSchema.parse({
				protocolId: "uniswap-v3",
				seasonId: "uniswap-v3:season-20241205-abc",
				parentId: "inv-001",
				childId: "path-001",
				relation: "violates",
			})
			expect(link.relation).toBe("violates")

			// 6. record_feedback
			const feedback = RecordFeedbackRequestSchema.parse({
				protocolId: "uniswap-v3",
				seasonId: "uniswap-v3:season-20241205-abc",
				testId: "test-001",
				status: "pass",
				profit: 50000,
				linkedPathId: "path-001",
			})
			expect(feedback.status).toBe("pass")

			// 7. snapshot/restore
			const snapshot = SnapshotRequestSchema.parse({
				protocolId: "uniswap-v3",
				seasonId: "uniswap-v3:season-20241205-abc",
			})
			expect(snapshot.seasonId).toBeDefined()

			const restore = RestoreRequestSchema.parse({
				protocolId: "uniswap-v3",
				snapshotId: "snapshot-001",
			})
			expect(restore.snapshotId).toBe("snapshot-001")
		})
	})

	describe("3. Reducer Verification", () => {
		it("should reduce Solidity source code correctly", () => {
			const source = `
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Pool {
    mapping(address => uint256) public balances;
    uint256 public totalSupply;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Swap(address indexed user, uint256 amountIn, uint256 amountOut);

    error InsufficientBalance();
    error InvalidAmount();

    function deposit() external payable {
        require(msg.value > 0, "Zero value");
        balances[msg.sender] += msg.value;
        totalSupply += msg.value;
    }

    function withdraw(uint256 amount) external {
        require(balances[msg.sender] >= amount, "Insufficient");
        balances[msg.sender] -= amount;
        totalSupply -= amount;
        payable(msg.sender).transfer(amount);
    }

    function swap(uint256 amountIn) external view returns (uint256) {
        require(amountIn > 0, "Zero amount");
        return amountIn * 99 / 100;
    }
}
`
			const result = reduceSourceCode(source)

			expect(result.summary).toContain("Contract Outline")
			expect(result.summary).toContain("State Variables")
			expect(result.summary).toContain("Functions")
			expect(result.summary).toContain("Modifiers")
			expect(result.summary).toContain("Security Checks")
			expect(result.summary).toContain("Events")
			expect(result.summary).toContain("Errors")

			expect(result.extractedMetadata.functionCount).toBeGreaterThan(0)
			expect(result.extractedMetadata.stateVarCount).toBeGreaterThan(0)
			expect(result.extractedMetadata.modifierCount).toBeGreaterThan(0)
			expect(result.extractedMetadata.requireCount).toBeGreaterThan(0)
			expect(result.extractedMetadata.eventCount).toBeGreaterThan(0)
			expect(result.extractedMetadata.errorCount).toBeGreaterThan(0)
		})

		it("should reduce ABI correctly", () => {
			const abi = JSON.stringify([
				{
					type: "function",
					name: "swap",
					inputs: [
						{ type: "uint256", name: "amountIn" },
						{ type: "address", name: "tokenOut" },
					],
					outputs: [{ type: "uint256", name: "amountOut" }],
					stateMutability: "nonpayable",
				},
				{
					type: "function",
					name: "getReserves",
					inputs: [],
					outputs: [
						{ type: "uint256", name: "reserve0" },
						{ type: "uint256", name: "reserve1" },
					],
					stateMutability: "view",
				},
				{
					type: "event",
					name: "Swap",
					inputs: [{ type: "address", name: "user", indexed: true }],
				},
				{
					type: "error",
					name: "InsufficientLiquidity",
					inputs: [],
				},
			])

			const result = reduceABI(abi)

			expect(result.summary).toContain("ABI Summary")
			expect(result.summary).toContain("Write Functions")
			expect(result.summary).toContain("Read Functions")
			expect(result.summary).toContain("Events")
			expect(result.summary).toContain("Errors")

			expect(result.extractedMetadata.totalFunctions).toBe(2)
			expect(result.extractedMetadata.writeFunctions).toBe(1)
			expect(result.extractedMetadata.readFunctions).toBe(1)
		})

		it("should reduce Forge logs correctly", () => {
			// Use exact format that forge outputs
			const logs = `
Running 3 tests for test/Exploit.t.sol:ExploitTest
[PASS] testFlashLoan (125ms)
[PASS] testSwapExploit (250ms)
Profit: 50000 USDC extracted
[FAIL] testReentrancy (150ms)
Revert: STF
Error: Insufficient liquidity
Suite result: FAILED
`
			const result = reduceForgeLogs(logs)

			expect(result.summary).toContain("Forge Test Results")
			expect(result.summary).toContain("Reverts")
			expect(result.summary).toContain("Profits")

			expect(result.extractedMetadata.passed).toBe(2)
			expect(result.extractedMetadata.failed).toBe(1)
			expect(result.extractedMetadata.revertCount).toBeGreaterThan(0)
		})

		it("should dispatch to correct reducer by kind", () => {
			expect(reduceByKind("source", "contract Test {}").summary).toContain("Contract Outline")
			// Empty array is valid JSON but has no items
			expect(reduceByKind("abi", "[]").summary).toContain("ABI Summary")
			expect(reduceByKind("forge_output", "[PASS] test (1ms)").summary).toContain("Forge Test")
			expect(reduceByKind("unknown", "content").summary).toBe("content")
		})
	})

	describe("4. Dedup & Novelty Verification", () => {
		const createEmbedding = (seed: number): number[] => {
			const embedding = new Array(128).fill(0)
			for (let i = 0; i < 128; i++) {
				embedding[i] = Math.sin(seed * (i + 1) * 0.1)
			}
			// Normalize
			const norm = Math.sqrt(embedding.reduce((sum, v) => sum + v * v, 0))
			return embedding.map((v) => v / norm)
		}

		it("should calculate cosine similarity correctly", () => {
			const v1 = [1, 0, 0]
			const v2 = [1, 0, 0]
			expect(cosineSimilarity(v1, v2)).toBeCloseTo(1.0, 5)

			const v3 = [0, 1, 0]
			expect(cosineSimilarity(v1, v3)).toBeCloseTo(0, 5)

			const v4 = [-1, 0, 0]
			expect(cosineSimilarity(v1, v4)).toBeCloseTo(-1, 5)
		})

		it("should detect duplicates correctly", () => {
			const existing = [
				{ id: "emb-1", embedding: createEmbedding(1) },
				{ id: "emb-2", embedding: createEmbedding(2) },
			]

			// Exact duplicate
			const exactDup = checkDuplicate(createEmbedding(1), existing)
			expect(exactDup.isDuplicate).toBe(true)
			expect(exactDup.maxSimilarity).toBeCloseTo(1.0, 3)
			expect(exactDup.duplicateOf).toBe("emb-1")

			// Novel embedding
			const novel = checkDuplicate(createEmbedding(100), existing)
			expect(novel.isDuplicate).toBe(false)
			expect(novel.noveltyScore).toBeGreaterThan(0.5)
		})

		it("should calculate novelty with pattern penalties", () => {
			const existing = [{ id: "emb-1", embedding: createEmbedding(50) }]
			const newEmb = createEmbedding(100)

			const baseNovelty = calculateNoveltyScore(newEmb, existing, null)
			const penalizedNovelty = calculateNoveltyScore(newEmb, existing, "first_depositor")

			expect(penalizedNovelty).toBeLessThan(baseNovelty)
		})

		it("should filter duplicates from batch", () => {
			const existing = [{ id: "emb-1", embedding: createEmbedding(1) }]

			const candidates = [
				{ id: "new-1", embedding: createEmbedding(1) }, // Duplicate
				{ id: "new-2", embedding: createEmbedding(50) }, // Novel
				{ id: "new-3", embedding: createEmbedding(100) }, // Novel
			]

			const filtered = filterDuplicates(candidates, existing)
			expect(filtered.length).toBe(2)
			expect(filtered.every((c) => c.noveltyScore > 0)).toBe(true)
		})

		it("should calculate diversity correctly", () => {
			const similar = [createEmbedding(1), createEmbedding(1.1), createEmbedding(1.2)]
			const diverse = [createEmbedding(1), createEmbedding(50), createEmbedding(100)]

			const similarDiversity = calculateDiversity(similar)
			const diverseDiversity = calculateDiversity(diverse)

			expect(diverseDiversity).toBeGreaterThan(similarDiversity)
		})
	})

	describe("5. Security Module Verification", () => {
		it("should redact all secret types", () => {
			const secrets = `
CONFIG:
- INFURA: https://mainnet.infura.io/v3/a1b2c3d4e5f6789012345678901234ab
- ALCHEMY: https://eth-mainnet.g.alchemy.com/v2/abcdefghijklmnopqrstuvwxyz123456
- PRIVATE_KEY: 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef
- AWS_ACCESS_KEY_ID: AKIAIOSFODNN7EXAMPLE
- AWS_SECRET_ACCESS_KEY: wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
- Bearer auth123456789012345678901234567890token
- JWT: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.dozjgNryP4J3jVmNHl0w5N_XgL0n3I9PlFUP0THsR8U
- SECRET=mysupersecretpassword123
`
			const result = redactSecrets(secrets)

			expect(result.redacted).not.toContain("a1b2c3d4e5f6789012345678901234ab")
			expect(result.redacted).not.toContain("abcdefghijklmnopqrstuvwxyz123456")
			expect(result.redacted).not.toContain("1234567890abcdef1234567890abcdef")
			expect(result.redacted).not.toContain("AKIAIOSFODNN7EXAMPLE")
			expect(result.redacted).not.toContain("mysupersecretpassword123")

			expect(result.redactedCount).toBeGreaterThan(5)
			expect(result.redactedTypes.length).toBeGreaterThan(3)
		})

		it("should detect sensitive content types", () => {
			const sensitiveContent = `
The database connection is: mongodb://admin:password@localhost:27017
Private key stored at /home/user/wallet/key.json
Total profit from exploit: $125,000
Username and password required for auth
`
			const result = checkSensitivity(sensitiveContent)

			expect(result.isSensitive).toBe(true)
			expect(result.types).toContain("database_credentials")
			expect(result.types).toContain("internal_paths")
			expect(result.types).toContain("credentials")
		})

		it("should sanitize content completely", () => {
			const content = `
RPC_URL=https://mainnet.infura.io/v3/a1b2c3d4e5f6789012345678901234ab
Path: /home/user/project/config.json
Some normal content here
`
			const result = sanitizeContent(content)

			expect(result.wasModified).toBe(true)
			expect(result.content).toContain("[REDACTED_INFURA_KEY]")
			expect(result.content).toContain("[INTERNAL_PATH]")
			expect(result.content).toContain("Some normal content here")
		})

		it("should process artifact for security with metadata", () => {
			const content = `
// Config with sensitive data
const rpc = "https://mainnet.infura.io/v3/a1b2c3d4e5f6789012345678901234ab";
const walletPath = "/home/user/wallet.json";
const dbConnection = "mongodb://admin:password@localhost:27017";
`
			const result = processArtifactForSecurity(content)

			expect(result.securityMetadata.wasRedacted).toBe(true)
			expect(result.securityMetadata.sanitizedAt).toBeInstanceOf(Date)
			// Content is sanitized, so we check wasRedacted instead
			expect(result.content).toContain("[REDACTED_INFURA_KEY]")
			expect(result.content).toContain("[INTERNAL_PATH]")
		})
	})

	describe("6. Metrics Module Verification", () => {
		let collector: ReturnType<typeof createMetricsCollector>

		beforeEach(() => {
			collector = createMetricsCollector("test-season", "test-protocol")
		})

		it("should track token usage with reduction ratio", () => {
			collector.recordTokenUsage({
				inputTokens: 1000,
				outputTokens: 500,
				rawLength: 10000,
				reducedLength: 2000,
				costUsd: 0.05,
			})

			const metrics = collector.getTokenMetrics()
			expect(metrics.inputTokens).toBe(1000)
			expect(metrics.outputTokens).toBe(500)
			expect(metrics.tokensSaved).toBeGreaterThan(0)
			expect(metrics.reductionRatio).toBeGreaterThan(0)
			expect(metrics.costUsd).toBe(0.05)
		})

		it("should track retrieval performance", () => {
			collector.recordRetrievalQuery({ resultCount: 5, latencyMs: 100, success: true })
			collector.recordRetrievalQuery({ resultCount: 3, latencyMs: 200, success: true })
			collector.recordRetrievalQuery({ resultCount: 0, latencyMs: 50, success: false })

			const metrics = collector.getRetrievalMetrics()
			expect(metrics.totalQueries).toBe(3)
			expect(metrics.successfulQueries).toBe(2)
			expect(metrics.hitRate).toBeCloseTo(2 / 3, 2)
			expect(metrics.averageResultCount).toBeCloseTo((5 + 3 + 0) / 3, 2)
			expect(metrics.averageLatencyMs).toBeCloseTo((100 + 200 + 50) / 3, 2)
		})

		it("should track dedup effectiveness", () => {
			collector.recordDedupCheck({ isDuplicate: false, noveltyScore: 0.9 })
			collector.recordDedupCheck({ isDuplicate: true, noveltyScore: 0.1 })
			collector.recordDedupCheck({ isDuplicate: false, noveltyScore: 0.5 })

			const metrics = collector.getDedupMetrics()
			expect(metrics.totalChecks).toBe(3)
			expect(metrics.duplicatesRejected).toBe(1)
			expect(metrics.rejectionRate).toBeCloseTo(1 / 3, 2)
			expect(metrics.averageNoveltyScore).toBeCloseTo(0.5, 2)
		})

		it("should track phase progress", () => {
			collector.startPhase("intake")
			collector.updatePhaseProgress("intake", { coverage: 50, artifactsGenerated: 10 })
			collector.completePhase("intake", 100)

			collector.startPhase("graphing")
			collector.updatePhaseProgress("graphing", { coverage: 25 })

			const coverage = collector.getPhaseCoverage()
			expect(coverage.intake).toBe(100)
			expect(coverage.graphing).toBe(25)
			expect(coverage.invariant).toBe(0)
		})

		it("should track execution metrics", () => {
			collector.recordExecution({ status: "pass", profit: 50000 })
			collector.recordExecution({ status: "pass", profit: 25000 })
			collector.recordExecution({ status: "fail" })
			collector.recordExecution({ status: "flaky" })

			const metrics = collector.getExecutionMetrics()
			expect(metrics.totalTests).toBe(4)
			expect(metrics.passed).toBe(2)
			expect(metrics.failed).toBe(1)
			expect(metrics.flaky).toBe(1)
			expect(metrics.passRate).toBe(0.5)
			expect(metrics.profitableCount).toBe(2)
			expect(metrics.totalProfit).toBe(75000)
			expect(metrics.averageProfit).toBe(37500)
		})

		it("should generate summary report", () => {
			collector.recordTokenUsage({ inputTokens: 1000, outputTokens: 500, rawLength: 4000, reducedLength: 1000 })
			collector.recordRetrievalQuery({ resultCount: 5, latencyMs: 100, success: true })
			collector.recordDedupCheck({ isDuplicate: false, noveltyScore: 0.8 })
			collector.recordExecution({ status: "pass", profit: 10000 })

			const report = collector.getSummaryReport()

			expect(report).toContain("Season Metrics Summary")
			expect(report).toContain("Token Usage")
			expect(report).toContain("Retrieval Performance")
			expect(report).toContain("Dedup Effectiveness")
			expect(report).toContain("Execution Results")
		})

		it("should serialize and deserialize metrics", () => {
			collector.recordTokenUsage({ inputTokens: 500, outputTokens: 250, rawLength: 2000, reducedLength: 500 })

			const json = collector.toJSON()
			const newCollector = createMetricsCollector("other", "other")
			newCollector.fromJSON(json)

			expect(newCollector.getMetrics().tokens.inputTokens).toBe(500)
		})
	})

	describe("7. Integration Workflows", () => {
		it("should support full exploit research workflow", () => {
			// 1. Create season
			const createSeason = CreateSeasonRequestSchema.parse({
				protocolId: "uniswap-v3",
			})
			expect(createSeason.protocolId).toBe("uniswap-v3")

			// 2. Log tool events during research
			const logEvent = LogEventRequestSchema.parse({
				protocolId: "uniswap-v3",
				seasonId: "uniswap-v3:season-20241205-abc",
				phase: "intake",
				toolName: "etherscan_fetch_source",
				toolCallId: "call-001",
				success: true,
				duration: 1500,
				rawContent: "contract Pool { function swap() external {} }",
			})
			expect(logEvent.toolName).toBe("etherscan_fetch_source")

			// 3. Store and reduce artifact
			const source = "contract Pool { function swap() external {} }"
			const reduced = reduceSourceCode(source)
			const storeArtifact = StoreArtifactRequestSchema.parse({
				protocolId: "uniswap-v3",
				seasonId: "uniswap-v3:season-20241205-abc",
				kind: "source",
				raw: source,
				summary: reduced.summary,
			})
			expect(storeArtifact.summary).toContain("Contract Outline")

			// 4. Check for duplicates before storing hypothesis
			const similar = SimilarRequestSchema.parse({
				protocolId: "uniswap-v3",
				seasonId: "uniswap-v3:season-20241205-abc",
				kind: "hypothesis",
				text: "Flash loan attack on swap function",
				threshold: 0.85,
			})
			expect(similar.kind).toBe("hypothesis")

			// 5. Create relationships
			const link = LinkRequestSchema.parse({
				protocolId: "uniswap-v3",
				seasonId: "uniswap-v3:season-20241205-abc",
				parentId: "inv-001",
				childId: "path-001",
				relation: "violates",
			})
			expect(link.relation).toBe("violates")

			// 6. Record test feedback
			const feedback = RecordFeedbackRequestSchema.parse({
				protocolId: "uniswap-v3",
				seasonId: "uniswap-v3:season-20241205-abc",
				testId: "test-001",
				status: "pass",
				profit: 50000,
				linkedPathId: "path-001",
				linkedInvariantIds: ["inv-001"],
				forgeLogsContent: "[PASS] testExploit (2.1s)\nProfit: 50000 USDC",
			})
			expect(feedback.profit).toBe(50000)

			// 7. Snapshot before closing
			const snapshot = SnapshotRequestSchema.parse({
				protocolId: "uniswap-v3",
				seasonId: "uniswap-v3:season-20241205-abc",
			})
			expect(snapshot.seasonId).toBeDefined()

			// 8. Close season
			const close = CloseSeasonRequestSchema.parse({
				protocolId: "uniswap-v3",
				seasonId: "uniswap-v3:season-20241205-abc",
			})
			expect(close.seasonId).toBeDefined()
		})

		it("should support cross-season import", () => {
			const importRequest = ImportSummariesRequestSchema.parse({
				targetSeasonId: "uniswap-v3:season-20241210-new",
				sourceSeasonId: "uniswap-v3:season-20241205-old",
				protocolId: "uniswap-v3",
				importInvariants: true,
				importPaths: false,
				importQuestions: true,
				minConfidence: 0.8,
			})

			expect(importRequest.importInvariants).toBe(true)
			expect(importRequest.minConfidence).toBe(0.8)
		})
	})
})
