import { describe, it, expect, vi, beforeEach } from "vitest"
import { createExploitResearchMiddleware } from "../middleware"
import type { ToolCallContext, MiddlewareConfig } from "../middleware"

// Mock fetch globally
const mockFetch = vi.fn()
global.fetch = mockFetch as any

describe("Middleware", () => {
	beforeEach(() => {
		mockFetch.mockReset()
	})

	const config: MiddlewareConfig = {
		apiKey: "test-api-key",
		baseUrl: "https://api.test.com",
		verbose: false,
	}

	const context: ToolCallContext = {
		protocolId: "uniswap-v3",
		seasonId: "uniswap-v3:season-20241205-abc123",
		phase: "invariant",
	}

	describe("wrapToolExecutor", () => {
		it("should wrap tool and store success result", async () => {
			mockFetch.mockResolvedValue({
				ok: true,
				json: async () => ({ id: "event-123", rawRef: null, summaryRef: null, embeddingId: null }),
			})

			const middleware = createExploitResearchMiddleware(config)
			const mockExecutor = vi.fn().mockResolvedValue("tool output")

			const wrapped = middleware.wrapToolExecutor(
				"test_tool",
				"source",
				mockExecutor,
			)

			const result = await wrapped({ input: "test" }, context)

			expect(result).toBe("tool output")
			expect(mockExecutor).toHaveBeenCalledWith({ input: "test" })
			expect(mockFetch).toHaveBeenCalled()

			// Verify the stored event
			const fetchCall = mockFetch.mock.calls[0]!
			expect(fetchCall[0]).toBe("https://api.test.com/v5/exploit-research/log-event")
			const body = JSON.parse(fetchCall[1].body)
			expect(body.protocolId).toBe("uniswap-v3")
			expect(body.seasonId).toBe(context.seasonId)
			expect(body.toolName).toBe("test_tool")
			expect(body.success).toBe(true)
		})

		it("should store failure event on error", async () => {
			mockFetch.mockResolvedValue({
				ok: true,
				json: async () => ({ id: "event-123" }),
			})

			const middleware = createExploitResearchMiddleware(config)
			const mockExecutor = vi.fn().mockRejectedValue(new Error("Tool failed"))

			const wrapped = middleware.wrapToolExecutor(
				"failing_tool",
				"source",
				mockExecutor,
			)

			await expect(wrapped({ input: "test" }, context)).rejects.toThrow(
				"Tool failed",
			)

			// Verify failure was stored
			const fetchCall = mockFetch.mock.calls[0]!
			const body = JSON.parse(fetchCall[1].body)
			expect(body.success).toBe(false)
			expect(body.metadata.error).toBe("Tool failed")
		})

		it("should apply reducer to output", async () => {
			mockFetch.mockResolvedValue({
				ok: true,
				json: async () => ({ id: "event-123" }),
			})

			const middleware = createExploitResearchMiddleware(config)
			const sourceCode = `
        contract Test {
          function deposit() public {}
          function withdraw() public {}
        }
      `
			const mockExecutor = vi.fn().mockResolvedValue(sourceCode)

			const wrapped = middleware.wrapToolExecutor(
				"fetch_source",
				"source",
				mockExecutor,
				{ shouldReduce: true },
			)

			await wrapped({}, context)

			// Verify reduced content was stored
			const fetchCall = mockFetch.mock.calls[0]!
			const body = JSON.parse(fetchCall[1].body)
			expect(body.summaryContent).toContain("Functions")
		})

		it("should extract target info when provided", async () => {
			mockFetch.mockResolvedValue({
				ok: true,
				json: async () => ({ id: "event-123" }),
			})

			const middleware = createExploitResearchMiddleware(config)
			const mockExecutor = vi.fn().mockResolvedValue("result")

			const wrapped = middleware.wrapToolExecutor(
				"analyze_function",
				"source",
				mockExecutor,
				{
					extractTarget: (input: { contract: string; func: string }) => ({
						contract: input.contract,
						function: input.func,
					}),
				},
			)

			await wrapped({ contract: "Pool", func: "swap" }, context)

			const fetchCall = mockFetch.mock.calls[0]!
			const body = JSON.parse(fetchCall[1].body)
			expect(body.targetContract).toBe("Pool")
			expect(body.targetFunction).toBe("swap")
		})

		it("should not reduce when shouldReduce is false", async () => {
			mockFetch.mockResolvedValue({
				ok: true,
				json: async () => ({ id: "event-123" }),
			})

			const middleware = createExploitResearchMiddleware(config)
			const rawOutput = '{"key": "value"}'
			const mockExecutor = vi.fn().mockResolvedValue(rawOutput)

			const wrapped = middleware.wrapToolExecutor(
				"raw_tool",
				"tool_output",
				mockExecutor,
				{ shouldReduce: false },
			)

			await wrapped({}, context)

			const fetchCall = mockFetch.mock.calls[0]!
			const body = JSON.parse(fetchCall[1].body)
			expect(body.summaryContent).toBe(rawOutput)
		})
	})

	describe("checkDuplicate", () => {
		it("should call similar API and return result", async () => {
			mockFetch.mockResolvedValue({
				ok: true,
				json: async () => ({
					isDuplicate: true,
					maxSimilarity: 0.95,
					results: [{ id: "existing-123", similarity: 0.95 }],
				}),
			})

			const middleware = createExploitResearchMiddleware(config)

			const result = await middleware.checkDuplicate(
				"hypothesis",
				"Flash loan attack on swap",
				context,
			)

			expect(result.isDuplicate).toBe(true)
			expect(result.duplicateOf).toBe("existing-123")
			expect(result.similarity).toBe(0.95)
		})

		it("should handle API errors gracefully", async () => {
			mockFetch.mockRejectedValue(new Error("Network error"))

			const middleware = createExploitResearchMiddleware(config)

			const result = await middleware.checkDuplicate(
				"hypothesis",
				"Some hypothesis",
				context,
			)

			expect(result.isDuplicate).toBe(false)
			expect(result.similarity).toBe(0)
		})

		it("should use custom threshold", async () => {
			mockFetch.mockResolvedValue({
				ok: true,
				json: async () => ({
					isDuplicate: false,
					maxSimilarity: 0.8,
					results: [],
				}),
			})

			const middleware = createExploitResearchMiddleware(config)

			await middleware.checkDuplicate(
				"hypothesis",
				"Some hypothesis",
				context,
				0.9,
			)

			const fetchCall = mockFetch.mock.calls[0]!
			const body = JSON.parse(fetchCall[1].body)
			expect(body.threshold).toBe(0.9)
		})
	})

	describe("buildPromptFromMemory", () => {
		it("should fetch and format memory sections", async () => {
			mockFetch
				// Season status
				.mockResolvedValueOnce({
					ok: true,
					json: async () => ({
						id: context.seasonId,
						coverage: { invariantsGenerated: 10, pathsExplored: 5 },
					}),
				})
				// Invariants
				.mockResolvedValueOnce({
					ok: true,
					json: async () => ({
						results: [
							{ id: "inv-1", summary: "Invariant 1 summary" },
							{ id: "inv-2", summary: "Invariant 2 summary" },
						],
					}),
				})
				// Paths
				.mockResolvedValueOnce({
					ok: true,
					json: async () => ({
						results: [{ id: "path-1", summary: "Path 1 summary" }],
					}),
				})

			const middleware = createExploitResearchMiddleware(config)

			const prompt = await middleware.buildPromptFromMemory(context, {
				includeInvariants: 5,
				includePaths: 3,
			})

			expect(prompt).toContain("Season Status")
			expect(prompt).toContain("Relevant Invariants")
			expect(prompt).toContain("Invariant 1 summary")
			expect(prompt).toContain("Relevant Paths")
		})

		it("should handle missing season status", async () => {
			mockFetch.mockResolvedValue({
				ok: false,
				status: 404,
				text: async () => "Not found",
			})

			const middleware = createExploitResearchMiddleware(config)

			const prompt = await middleware.buildPromptFromMemory(context, {})

			// Should still work, just without season status
			expect(prompt).toBe("")
		})

		it("should include contract focus when specified", async () => {
			mockFetch
				// Season status
				.mockResolvedValueOnce({
					ok: true,
					json: async () => ({ id: context.seasonId, coverage: {} }),
				})
				// Contract focus
				.mockResolvedValueOnce({
					ok: true,
					json: async () => ({
						results: [{ id: "ctx-1", summary: "Pool contract context" }],
					}),
				})

			const middleware = createExploitResearchMiddleware(config)

			const prompt = await middleware.buildPromptFromMemory(context, {
				contractFocus: "Pool",
			})

			expect(prompt).toContain("Contract Focus: Pool")
			expect(prompt).toContain("Pool contract context")
		})
	})

	describe("recordTestFeedback", () => {
		it("should call feedback API with linked entities", async () => {
			mockFetch.mockResolvedValue({
				ok: true,
				json: async () => ({
					id: "feedback-123",
					updatedEntities: [
						{
							id: "path-1",
							type: "path",
							field: "confirmedCount",
							oldValue: 0,
							newValue: 1,
						},
					],
				}),
			})

			const middleware = createExploitResearchMiddleware(config)

			const response = await middleware.recordTestFeedback(
				"test-123",
				{ status: "pass", profit: 50000 },
				{ pathId: "path-1", invariantIds: ["inv-1"] },
				context,
			)

			expect(response.id).toBe("feedback-123")
			expect(response.updatedEntities).toHaveLength(1)

			const fetchCall = mockFetch.mock.calls[0]!
			const body = JSON.parse(fetchCall[1].body)
			expect(body.testId).toBe("test-123")
			expect(body.status).toBe("pass")
			expect(body.profit).toBe(50000)
			expect(body.linkedPathId).toBe("path-1")
			expect(body.linkedInvariantIds).toContain("inv-1")
		})

		it("should handle failed test feedback", async () => {
			mockFetch.mockResolvedValue({
				ok: true,
				json: async () => ({
					id: "feedback-124",
					updatedEntities: [],
				}),
			})

			const middleware = createExploitResearchMiddleware(config)

			await middleware.recordTestFeedback(
				"test-124",
				{
					status: "fail",
					revertReason: "STF",
					failureDetails: "Insufficient liquidity",
				},
				{},
				context,
			)

			const fetchCall = mockFetch.mock.calls[0]!
			const body = JSON.parse(fetchCall[1].body)
			expect(body.status).toBe("fail")
			expect(body.revertReason).toBe("STF")
			expect(body.failureDetails).toBe("Insufficient liquidity")
		})
	})

	describe("storeArtifact", () => {
		it("should store artifact with reduced content", async () => {
			mockFetch.mockResolvedValue({
				ok: true,
				json: async () => ({
					id: "artifact-123",
					embeddingId: "emb-123",
					rawHash: "hash-123",
				}),
			})

			const middleware = createExploitResearchMiddleware(config)

			const response = await middleware.storeArtifact(
				"source",
				"function test() public {}",
				context,
			)

			expect(response.id).toBe("artifact-123")

			const fetchCall = mockFetch.mock.calls[0]!
			const body = JSON.parse(fetchCall[1].body)
			expect(body.kind).toBe("source")
			expect(body.raw).toBe("function test() public {}")
			expect(body.summary).toContain("Functions")
		})

		it("should allow custom summary and metadata", async () => {
			mockFetch.mockResolvedValue({
				ok: true,
				json: async () => ({ id: "artifact-124" }),
			})

			const middleware = createExploitResearchMiddleware(config)

			await middleware.storeArtifact("invariant", '{"formula": "x > 0"}', context, {
				summary: "Custom summary",
				metadata: { severity: "high" },
				retainDays: 60,
			})

			const fetchCall = mockFetch.mock.calls[0]!
			const body = JSON.parse(fetchCall[1].body)
			expect(body.summary).toBe("Custom summary")
			expect(body.metadata.severity).toBe("high")
			expect(body.retainDays).toBe(60)
		})
	})

	describe("retrieveContext", () => {
		it("should retrieve relevant context", async () => {
			mockFetch.mockResolvedValue({
				ok: true,
				json: async () => ({
					results: [
						{ id: "ctx-1", summary: "Relevant context", similarity: 0.9 },
					],
					total: 1,
					timing: 100,
				}),
			})

			const middleware = createExploitResearchMiddleware(config)

			const results = await middleware.retrieveContext(
				"flash loan vulnerability",
				context,
				{ kind: "invariant", limit: 5 },
			)

			expect(results).toHaveLength(1)
			expect(results[0]!.summary).toBe("Relevant context")

			const fetchCall = mockFetch.mock.calls[0]!
			const body = JSON.parse(fetchCall[1].body)
			expect(body.query).toBe("flash loan vulnerability")
			expect(body.filters.kind).toBe("invariant")
			expect(body.limit).toBe(5)
		})

		it("should use default options", async () => {
			mockFetch.mockResolvedValue({
				ok: true,
				json: async () => ({ results: [], total: 0, timing: 50 }),
			})

			const middleware = createExploitResearchMiddleware(config)

			await middleware.retrieveContext("test query", context)

			const fetchCall = mockFetch.mock.calls[0]!
			const body = JSON.parse(fetchCall[1].body)
			expect(body.limit).toBe(10)
			expect(body.threshold).toBe(0.5)
			expect(body.includeRaw).toBe(false)
		})
	})

	describe("verbose logging", () => {
		it("should log when verbose is enabled", async () => {
			const consoleSpy = vi.spyOn(console, "log").mockImplementation(() => {})
			mockFetch.mockResolvedValue({
				ok: true,
				json: async () => ({ id: "event-123" }),
			})

			const verboseConfig = { ...config, verbose: true }
			const middleware = createExploitResearchMiddleware(verboseConfig)
			const mockExecutor = vi.fn().mockResolvedValue("output")

			const wrapped = middleware.wrapToolExecutor(
				"test_tool",
				"source",
				mockExecutor,
			)

			await wrapped({}, context)

			expect(consoleSpy).toHaveBeenCalledWith(
				expect.stringContaining("[test_tool]"),
			)

			consoleSpy.mockRestore()
		})

		it("should not log when verbose is disabled", async () => {
			const consoleSpy = vi.spyOn(console, "log")
			mockFetch.mockResolvedValue({
				ok: true,
				json: async () => ({ id: "event-123" }),
			})

			const middleware = createExploitResearchMiddleware(config) // verbose: false
			const mockExecutor = vi.fn().mockResolvedValue("output")

			const wrapped = middleware.wrapToolExecutor(
				"test_tool",
				"source",
				mockExecutor,
			)

			await wrapped({}, context)

			expect(consoleSpy).not.toHaveBeenCalled()

			consoleSpy.mockRestore()
		})
	})
})
