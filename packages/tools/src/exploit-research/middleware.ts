/**
 * Middleware for intercepting tool calls and storing to Supermemory
 */

import { reduceByKind, type ReducerResult } from "./reducers"
import type {
	Phase,
	ArtifactKind,
} from "@repo/validation/exploit-research-schemas"
import type {
	LogEventRequest,
	LogEventResponse,
	StoreArtifactRequest,
	StoreArtifactResponse,
	RetrieveRequest,
	RetrieveResponse,
	SimilarRequest,
	SimilarResponse,
	RecordFeedbackRequest,
	RecordFeedbackResponse,
} from "@repo/validation/exploit-research-api"

export interface ToolCallContext {
	protocolId: string
	seasonId: string
	phase: Phase
}

export interface MiddlewareConfig {
	apiKey: string
	baseUrl?: string
	verbose?: boolean
	autoEmbed?: boolean
}

export interface SeasonStatus {
	id: string
	protocolId: string
	status: string
	coverage: {
		contractsAnalyzed: number
		functionsAnalyzed: number
		invariantsGenerated: number
		pathsExplored: number
		scenariosGenerated: number
		testsRun: number
		testsPassed: number
		testsFailed: number
		profitableExploits: number
	}
}

export interface RetrieveResult {
	id: string
	kind: string
	summary: string | null
	raw: string | null
	similarity: number
	metadata: Record<string, unknown> | null
	createdAt: Date
}

/**
 * Helper function for making API requests with error handling
 */
async function apiRequest<T>(
	url: string,
	options: RequestInit,
	config: MiddlewareConfig,
): Promise<T> {
	const response = await fetch(url, {
		...options,
		headers: {
			"Content-Type": "application/json",
			Authorization: `Bearer ${config.apiKey}`,
			...options.headers,
		},
	})

	if (!response.ok) {
		const error = await response.text()
		throw new Error(`API request failed: ${response.status} - ${error}`)
	}

	return response.json()
}

/**
 * Store a tool event to Supermemory
 */
async function storeToolEvent(
	payload: LogEventRequest,
	config: MiddlewareConfig,
): Promise<LogEventResponse> {
	const baseUrl = config.baseUrl || "https://api.supermemory.com"
	return apiRequest<LogEventResponse>(
		`${baseUrl}/v5/exploit-research/log-event`,
		{
			method: "POST",
			body: JSON.stringify(payload),
		},
		config,
	)
}

/**
 * Store an artifact to Supermemory
 */
async function storeArtifact(
	payload: StoreArtifactRequest,
	config: MiddlewareConfig,
): Promise<StoreArtifactResponse> {
	const baseUrl = config.baseUrl || "https://api.supermemory.com"
	return apiRequest<StoreArtifactResponse>(
		`${baseUrl}/v5/exploit-research/artifacts`,
		{
			method: "POST",
			body: JSON.stringify(payload),
		},
		config,
	)
}

/**
 * Fetch season status from Supermemory
 */
async function fetchSeasonStatus(
	seasonId: string,
	config: MiddlewareConfig,
): Promise<SeasonStatus | null> {
	const baseUrl = config.baseUrl || "https://api.supermemory.com"
	try {
		return await apiRequest<SeasonStatus>(
			`${baseUrl}/v5/exploit-research/seasons/${encodeURIComponent(seasonId)}`,
			{ method: "GET" },
			config,
		)
	} catch {
		return null
	}
}

/**
 * Retrieve artifacts from Supermemory
 */
async function retrieveArtifacts(
	params: RetrieveRequest,
	config: MiddlewareConfig,
): Promise<RetrieveResult[]> {
	const baseUrl = config.baseUrl || "https://api.supermemory.com"
	try {
		const response = await apiRequest<RetrieveResponse>(
			`${baseUrl}/v5/exploit-research/retrieve`,
			{
				method: "POST",
				body: JSON.stringify(params),
			},
			config,
		)
		return response.results
	} catch {
		return []
	}
}

/**
 * Record feedback from test execution
 */
async function recordFeedback(
	payload: RecordFeedbackRequest,
	config: MiddlewareConfig,
): Promise<RecordFeedbackResponse> {
	const baseUrl = config.baseUrl || "https://api.supermemory.com"
	return apiRequest<RecordFeedbackResponse>(
		`${baseUrl}/v5/exploit-research/feedback`,
		{
			method: "POST",
			body: JSON.stringify(payload),
		},
		config,
	)
}

/**
 * Check for similar artifacts (dedup)
 */
async function checkSimilar(
	params: SimilarRequest,
	config: MiddlewareConfig,
): Promise<SimilarResponse> {
	const baseUrl = config.baseUrl || "https://api.supermemory.com"
	try {
		return await apiRequest<SimilarResponse>(
			`${baseUrl}/v5/exploit-research/similar`,
			{
				method: "POST",
				body: JSON.stringify(params),
			},
			config,
		)
	} catch {
		return { isDuplicate: false, maxSimilarity: 0, results: [] }
	}
}

/**
 * Create middleware that intercepts tool outputs and stores them
 */
export function createExploitResearchMiddleware(config: MiddlewareConfig) {
	const log = config.verbose ? console.log : () => {}

	return {
		/**
		 * Wrap a tool executor to automatically store outputs
		 */
		wrapToolExecutor<TInput, TOutput>(
			toolName: string,
			artifactKind: ArtifactKind,
			executor: (input: TInput) => Promise<TOutput>,
			options?: {
				extractTarget?: (input: TInput) => {
					contract?: string
					function?: string
				}
				shouldReduce?: boolean
			},
		) {
			return async (
				input: TInput,
				context: ToolCallContext,
			): Promise<TOutput> => {
				const startTime = Date.now()
				const toolCallId = `${context.seasonId}:tool-${Date.now()}-${Math.random().toString(36).slice(2, 10)}`

				try {
					log(`[${toolName}] Executing...`)
					const result = await executor(input)
					const duration = Date.now() - startTime

					// Convert result to string for storage
					const rawOutput =
						typeof result === "string" ? result : JSON.stringify(result)

					// Apply reducer
					const reduced: ReducerResult =
						options?.shouldReduce !== false
							? reduceByKind(artifactKind, rawOutput)
							: {
									summary: rawOutput,
									shouldStoreRaw: true,
									extractedMetadata: {},
								}

					// Extract target info
					const target = options?.extractTarget?.(input) || {}

					// Store the event (fire and forget - don't block on storage errors)
					storeToolEvent(
						{
							protocolId: context.protocolId,
							seasonId: context.seasonId,
							phase: context.phase,
							toolName,
							toolCallId,
							targetContract: target.contract,
							targetFunction: target.function,
							success: true,
							duration,
							rawContent: reduced.shouldStoreRaw ? rawOutput : undefined,
							summaryContent: reduced.summary,
							metadata: reduced.extractedMetadata as Record<
								string,
								string | number | boolean
							>,
						},
						config,
					).catch((err) => {
						// Log but don't throw - storage should not block execution
						log(`[${toolName}] Warning: Failed to store event: ${err}`)
					})

					log(`[${toolName}] Completed in ${duration}ms`)

					return result
				} catch (error) {
					const duration = Date.now() - startTime

					// Store failure event
					await storeToolEvent(
						{
							protocolId: context.protocolId,
							seasonId: context.seasonId,
							phase: context.phase,
							toolName,
							toolCallId,
							success: false,
							duration,
							metadata: {
								error:
									error instanceof Error ? error.message : String(error),
							},
						},
						config,
					).catch(() => {
						// Ignore errors when storing failure events
					})

					throw error
				}
			}
		},

		/**
		 * Build prompt from Supermemory instead of chat history
		 */
		async buildPromptFromMemory(
			context: ToolCallContext,
			options: {
				includeInvariants?: number // top-k
				includePaths?: number
				includeTests?: number
				includeQuestions?: number
				contractFocus?: string
				query?: string
			},
		): Promise<string> {
			const sections: string[] = []

			// Fetch season status
			const season = await fetchSeasonStatus(context.seasonId, config)
			if (season) {
				sections.push(`## Season Status
Protocol: ${context.protocolId}
Season: ${context.seasonId}
Phase: ${context.phase}
Coverage: ${JSON.stringify(season.coverage)}`)
			}

			// Fetch relevant invariants
			if (options.includeInvariants) {
				const invariants = await retrieveArtifacts(
					{
						protocolId: context.protocolId,
						seasonId: context.seasonId,
						query: options.query || "security vulnerability invariant",
						filters: { kind: "invariant" },
						limit: options.includeInvariants,
					},
					config,
				)

				if (invariants.length > 0) {
					sections.push(`## Relevant Invariants (${invariants.length})
${invariants.map((inv) => inv.summary).join("\n\n")}`)
				}
			}

			// Fetch relevant paths
			if (options.includePaths) {
				const paths = await retrieveArtifacts(
					{
						protocolId: context.protocolId,
						seasonId: context.seasonId,
						query: options.query || "exploit path attack vector",
						filters: { kind: "path" },
						limit: options.includePaths,
					},
					config,
				)

				if (paths.length > 0) {
					sections.push(`## Relevant Paths (${paths.length})
${paths.map((p) => p.summary).join("\n\n")}`)
				}
			}

			// Fetch recent test results
			if (options.includeTests) {
				const tests = await retrieveArtifacts(
					{
						protocolId: context.protocolId,
						seasonId: context.seasonId,
						query: "test execution result",
						filters: { kind: "execution" },
						limit: options.includeTests,
					},
					config,
				)

				if (tests.length > 0) {
					sections.push(`## Recent Test Results (${tests.length})
${tests.map((t) => t.summary).join("\n\n")}`)
				}
			}

			// Contract-specific context
			if (options.contractFocus) {
				const contractContext = await retrieveArtifacts(
					{
						protocolId: context.protocolId,
						seasonId: context.seasonId,
						query: options.contractFocus,
						filters: { contract: options.contractFocus },
						limit: 5,
					},
					config,
				)

				if (contractContext.length > 0) {
					sections.push(`## Contract Focus: ${options.contractFocus}
${contractContext.map((c) => c.summary).join("\n\n")}`)
				}
			}

			return sections.join("\n\n---\n\n")
		},

		/**
		 * Record feedback from test execution
		 */
		async recordTestFeedback(
			testId: string,
			result: {
				status: "pending" | "running" | "pass" | "fail" | "flaky" | "inconclusive" | "error"
				profit?: number
				revertReason?: string
				failureDetails?: string
				forgeLogsContent?: string
			},
			linkedIds: {
				pathId?: string
				scenarioId?: string
				invariantIds?: string[]
			},
			context: ToolCallContext,
		): Promise<RecordFeedbackResponse> {
			return recordFeedback(
				{
					protocolId: context.protocolId,
					seasonId: context.seasonId,
					testId,
					...result,
					linkedPathId: linkedIds.pathId,
					linkedScenarioId: linkedIds.scenarioId,
					linkedInvariantIds: linkedIds.invariantIds,
				},
				config,
			)
		},

		/**
		 * Check for duplicates before creating hypothesis/test
		 */
		async checkDuplicate(
			kind: ArtifactKind,
			content: string,
			context: ToolCallContext,
			threshold = 0.85,
		): Promise<{
			isDuplicate: boolean
			duplicateOf?: string
			similarity: number
		}> {
			const result = await checkSimilar(
				{
					protocolId: context.protocolId,
					seasonId: context.seasonId,
					kind,
					text: content,
					threshold,
					limit: 1,
				},
				config,
			)

			return {
				isDuplicate: result.isDuplicate,
				duplicateOf: result.results[0]?.id,
				similarity: result.maxSimilarity,
			}
		},

		/**
		 * Store an artifact directly
		 */
		async storeArtifact(
			kind: ArtifactKind,
			content: string,
			context: ToolCallContext,
			options?: {
				summary?: string
				metadata?: Record<string, string | number | boolean>
				retainDays?: number
			},
		): Promise<StoreArtifactResponse> {
			const reduced = reduceByKind(kind, content)

			return storeArtifact(
				{
					protocolId: context.protocolId,
					seasonId: context.seasonId,
					kind,
					raw: content,
					summary: options?.summary || reduced.summary,
					metadata: {
						...(reduced.extractedMetadata as Record<
							string,
							string | number | boolean
						>),
						...options?.metadata,
					},
					retainDays: options?.retainDays,
				},
				config,
			)
		},

		/**
		 * Retrieve relevant context for a query
		 */
		async retrieveContext(
			query: string,
			context: ToolCallContext,
			options?: {
				kind?: ArtifactKind
				limit?: number
				threshold?: number
				includeRaw?: boolean
			},
		): Promise<RetrieveResult[]> {
			return retrieveArtifacts(
				{
					protocolId: context.protocolId,
					seasonId: context.seasonId,
					query,
					filters: options?.kind ? { kind: options.kind } : undefined,
					limit: options?.limit ?? 10,
					threshold: options?.threshold ?? 0.5,
					includeRaw: options?.includeRaw ?? false,
				},
				config,
			)
		},
	}
}

// Type for the middleware instance
export type ExploitResearchMiddleware = ReturnType<
	typeof createExploitResearchMiddleware
>

// Export the middleware factory and helpers
export const middleware = {
	createExploitResearchMiddleware,
	storeToolEvent,
	storeArtifact,
	fetchSeasonStatus,
	retrieveArtifacts,
	recordFeedback,
	checkSimilar,
} as const
