/**
 * Security utilities for the exploit research system
 *
 * Provides:
 * - Secret redaction (RPC keys, API keys, private keys)
 * - Sensitive artifact marking
 * - Content sanitization
 */

// ============================================================================
// SECRET PATTERNS
// ============================================================================

/**
 * Patterns to detect and redact secrets
 */
const SECRET_PATTERNS: Array<{
	name: string
	pattern: RegExp
	replacement: string
}> = [
	// JSON Web Tokens (must be before generic patterns)
	{
		name: "jwt",
		pattern: /eyJ[a-zA-Z0-9_-]*\.eyJ[a-zA-Z0-9_-]*\.[a-zA-Z0-9_-]*/g,
		replacement: "[REDACTED_JWT]",
	},
	// API Keys (generic)
	{
		name: "api_key",
		pattern: /(?:api[_-]?key|apikey)\s*[:=]\s*["']?([a-zA-Z0-9_-]{20,})["']?/gi,
		replacement: "[REDACTED_API_KEY]",
	},
	// Infura RPC URLs
	{
		name: "infura_rpc",
		pattern: /https?:\/\/(?:mainnet|goerli|sepolia|arbitrum-mainnet)\.infura\.io\/v3\/[a-f0-9]{32}/gi,
		replacement: "https://mainnet.infura.io/v3/[REDACTED_INFURA_KEY]",
	},
	// Alchemy RPC URLs
	{
		name: "alchemy_rpc",
		pattern: /https?:\/\/eth-(?:mainnet|goerli|sepolia)\.(?:g\.)?alchemy\.com\/v2\/[a-zA-Z0-9_-]{32}/gi,
		replacement: "https://eth-mainnet.alchemy.com/v2/[REDACTED_ALCHEMY_KEY]",
	},
	// Generic RPC URLs with keys (32+ char keys at end of URL)
	{
		name: "rpc_url_with_key",
		pattern: /https?:\/\/[^/\s]+\/(?:v[123]\/)?[a-zA-Z0-9_-]{32,}/gi,
		replacement: "[REDACTED_RPC_URL]",
	},
	// Private keys (hex)
	{
		name: "private_key_hex",
		pattern: /(?:private[_-]?key|PRIVATE[_-]?KEY|0x)[:\s=]*[a-fA-F0-9]{64}/gi,
		replacement: "[REDACTED_PRIVATE_KEY]",
	},
	// Mnemonic phrases (12/24 word)
	{
		name: "mnemonic",
		pattern: /\b((?:[a-z]+\s+){11,23}[a-z]+)\b/gi,
		replacement: "[REDACTED_MNEMONIC]",
	},
	// Bearer tokens
	{
		name: "bearer_token",
		pattern: /Bearer\s+[a-zA-Z0-9._-]{20,}/gi,
		replacement: "Bearer [REDACTED_TOKEN]",
	},
	// AWS credentials
	{
		name: "aws_access_key",
		pattern: /(?:AWS_ACCESS_KEY_ID|aws_access_key_id)\s*[:=]\s*["']?AKIA[A-Z0-9]{16}["']?/gi,
		replacement: "[REDACTED_AWS_ACCESS_KEY]",
	},
	{
		name: "aws_secret_key",
		pattern: /(?:AWS_SECRET_ACCESS_KEY|aws_secret_access_key)\s*[:=]\s*["']?[a-zA-Z0-9/+=]{40}["']?/gi,
		replacement: "[REDACTED_AWS_SECRET_KEY]",
	},
	// Etherscan API keys
	{
		name: "etherscan_key",
		pattern: /(?:ETHERSCAN_API_KEY|etherscan[_-]?api[_-]?key)\s*[:=]\s*["']?[A-Z0-9]{34}["']?/gi,
		replacement: "[REDACTED_ETHERSCAN_KEY]",
	},
	// Generic secret patterns (must be last to not override specific patterns)
	{
		name: "generic_secret",
		pattern: /(?:SECRET|PASSWORD|PASSWD|TOKEN|CREDENTIAL)\s*[:=]\s*["']?[^\s"']{8,}["']?/gi,
		replacement: "[REDACTED_SECRET]",
	},
]

export interface RedactionResult {
	redacted: string
	redactedCount: number
	redactedTypes: string[]
}

/**
 * Redact secrets from a string
 */
export function redactSecrets(content: string): RedactionResult {
	let redacted = content
	const redactedTypes: string[] = []
	let redactedCount = 0

	for (const { name, pattern, replacement } of SECRET_PATTERNS) {
		const matches = redacted.match(pattern)
		if (matches) {
			redactedCount += matches.length
			if (!redactedTypes.includes(name)) {
				redactedTypes.push(name)
			}
			if (typeof replacement === "function") {
				redacted = redacted.replace(pattern, replacement as (match: string) => string)
			} else {
				redacted = redacted.replace(pattern, replacement)
			}
		}
	}

	return {
		redacted,
		redactedCount,
		redactedTypes,
	}
}

/**
 * Check if content contains secrets
 */
export function containsSecrets(content: string): boolean {
	for (const { pattern } of SECRET_PATTERNS) {
		if (pattern.test(content)) {
			return true
		}
		// Reset regex state for global patterns
		pattern.lastIndex = 0
	}
	return false
}

// ============================================================================
// SENSITIVE CONTENT DETECTION
// ============================================================================

/**
 * Types of sensitive content
 */
export type SensitiveContentType =
	| "credentials"
	| "private_key"
	| "financial_data"
	| "personal_info"
	| "internal_paths"
	| "database_credentials"

/**
 * Patterns to detect sensitive content that should be marked
 */
const SENSITIVE_PATTERNS: Array<{
	type: SensitiveContentType
	pattern: RegExp
	description: string
}> = [
	{
		type: "credentials",
		pattern: /(?:username|password|passwd|secret|credential|auth)/gi,
		description: "Contains credential-related keywords",
	},
	{
		type: "private_key",
		pattern: /(?:BEGIN\s+(?:RSA\s+)?PRIVATE\s+KEY|private[_-]?key|wallet[_-]?key)/gi,
		description: "Contains private key indicators",
	},
	{
		type: "financial_data",
		pattern: /(?:profit|balance|treasury|vault|funds).*\d+(?:\.\d+)?/gi,
		description: "Contains financial amounts",
	},
	{
		type: "internal_paths",
		pattern: /(?:\/home\/\w+|\/Users\/\w+|C:\\Users\\\w+)/gi,
		description: "Contains internal file paths",
	},
	{
		type: "database_credentials",
		pattern: /(?:mongodb|mysql|postgres|redis):\/\/[^@]+@/gi,
		description: "Contains database connection strings",
	},
]

export interface SensitivityCheck {
	isSensitive: boolean
	types: SensitiveContentType[]
	reasons: string[]
}

/**
 * Check if content is sensitive and should be marked
 */
export function checkSensitivity(content: string): SensitivityCheck {
	const types: SensitiveContentType[] = []
	const reasons: string[] = []

	// First check for actual secrets
	if (containsSecrets(content)) {
		types.push("credentials")
		reasons.push("Contains redacted secrets")
	}

	// Check sensitive patterns
	for (const { type, pattern, description } of SENSITIVE_PATTERNS) {
		if (pattern.test(content)) {
			if (!types.includes(type)) {
				types.push(type)
				reasons.push(description)
			}
		}
		// Reset regex state for global patterns
		pattern.lastIndex = 0
	}

	return {
		isSensitive: types.length > 0,
		types,
		reasons,
	}
}

// ============================================================================
// CONTENT SANITIZATION
// ============================================================================

export interface SanitizeOptions {
	redactSecrets?: boolean
	removeInternalPaths?: boolean
	maxLength?: number
}

export interface SanitizeResult {
	content: string
	wasModified: boolean
	modifications: string[]
	sensitivity: SensitivityCheck
}

/**
 * Sanitize content before storage
 */
export function sanitizeContent(
	content: string,
	options: SanitizeOptions = {},
): SanitizeResult {
	const {
		redactSecrets: shouldRedact = true,
		removeInternalPaths = true,
		maxLength,
	} = options

	let sanitized = content
	const modifications: string[] = []

	// Redact secrets
	if (shouldRedact) {
		const redaction = redactSecrets(sanitized)
		if (redaction.redactedCount > 0) {
			sanitized = redaction.redacted
			modifications.push(`Redacted ${redaction.redactedCount} secrets (${redaction.redactedTypes.join(", ")})`)
		}
	}

	// Remove internal paths
	if (removeInternalPaths) {
		const pathPattern = /(?:\/home\/\w+|\/Users\/\w+|C:\\Users\\\w+)/g
		const pathMatches = sanitized.match(pathPattern)
		if (pathMatches) {
			sanitized = sanitized.replace(pathPattern, "[INTERNAL_PATH]")
			modifications.push(`Removed ${pathMatches.length} internal paths`)
		}
	}

	// Truncate if needed
	if (maxLength && sanitized.length > maxLength) {
		sanitized = sanitized.slice(0, maxLength) + "\n... [TRUNCATED]"
		modifications.push(`Truncated from ${content.length} to ${maxLength} chars`)
	}

	// Check final sensitivity
	const sensitivity = checkSensitivity(sanitized)

	return {
		content: sanitized,
		wasModified: modifications.length > 0,
		modifications,
		sensitivity,
	}
}

// ============================================================================
// ARTIFACT SENSITIVITY HELPERS
// ============================================================================

export interface ArtifactSecurityMetadata {
	isSensitive: boolean
	sensitivityTypes: SensitiveContentType[]
	wasRedacted: boolean
	redactedTypes: string[]
	sanitizedAt: Date
}

/**
 * Process artifact content for security
 * Returns sanitized content and security metadata
 */
export function processArtifactForSecurity(
	content: string,
	options: SanitizeOptions = {},
): {
	content: string
	securityMetadata: ArtifactSecurityMetadata
} {
	const result = sanitizeContent(content, options)

	return {
		content: result.content,
		securityMetadata: {
			isSensitive: result.sensitivity.isSensitive,
			sensitivityTypes: result.sensitivity.types,
			wasRedacted: result.wasModified,
			redactedTypes: result.modifications
				.filter((m) => m.startsWith("Redacted"))
				.map((m) => m.replace(/^Redacted \d+ secrets \(|\)$/g, ""))
				.flatMap((m) => m.split(", ")),
			sanitizedAt: new Date(),
		},
	}
}

// ============================================================================
// EXPORTS
// ============================================================================

export const security = {
	redactSecrets,
	containsSecrets,
	checkSensitivity,
	sanitizeContent,
	processArtifactForSecurity,
	SECRET_PATTERNS,
	SENSITIVE_PATTERNS,
} as const
