import { z } from "zod"
import "zod-openapi/extend"
import {
	PhaseEnum,
	ArtifactKindEnum,
	TestStatusEnum,
	ExploitRelationEnum,
	SeasonStatusEnum,
	SeasonCoverageSchema,
} from "./exploit-research-schemas"

// ============================================================================
// log_event API
// ============================================================================

export const LogEventRequestSchema = z.object({
	protocolId: z.string().openapi({
		description: "Protocol identifier (hard isolation boundary)",
		example: "uniswap-v3",
	}),
	seasonId: z.string().openapi({
		description: "Season identifier",
		example: "uniswap-v3:season-20241205-abc123",
	}),
	phase: PhaseEnum.openapi({
		description: "Current phase of the exploit research",
		example: "invariant",
	}),
	toolName: z.string().openapi({
		description: "Name of the tool that was called",
		example: "etherscan_fetch_source",
	}),
	toolCallId: z.string().openapi({
		description: "External tool call ID",
		example: "call_abc123",
	}),

	// Target (optional)
	targetContract: z.string().optional().openapi({
		description: "Target contract address or identifier",
		example: "0x1234567890abcdef1234567890abcdef12345678",
	}),
	targetFunction: z.string().optional().openapi({
		description: "Target function name",
		example: "swap",
	}),
	targetInvariantId: z.string().optional().openapi({
		description: "Target invariant ID",
		example: "inv-001",
	}),
	targetPathId: z.string().optional().openapi({
		description: "Target path ID",
		example: "path-001",
	}),
	targetTestId: z.string().optional().openapi({
		description: "Target test ID",
		example: "test-001",
	}),

	// Result
	success: z.boolean().openapi({
		description: "Whether the tool call succeeded",
		example: true,
	}),
	duration: z.number().optional().openapi({
		description: "Duration of the tool call in milliseconds",
		example: 1250,
	}),

	// Token tracking
	inputTokens: z.number().optional().openapi({
		description: "Number of input tokens used",
		example: 100,
	}),
	outputTokens: z.number().optional().openapi({
		description: "Number of output tokens generated",
		example: 500,
	}),
	costUsd: z.number().optional().openapi({
		description: "Cost of the tool call in USD",
		example: 0.01,
	}),

	// Content (will be processed into raw/summary/embedding)
	rawContent: z.string().optional().openapi({
		description: "Raw content from the tool output",
		example: "// SPDX-License-Identifier: MIT...",
	}),
	summaryContent: z.string().optional().openapi({
		description: "Summarized content from the tool output",
		example: "Contract with 5 functions and 3 state variables",
	}),

	metadata: z
		.record(z.union([z.string(), z.number(), z.boolean()]))
		.optional()
		.openapi({
			description: "Additional metadata",
			example: { chain: "ethereum", verified: true },
		}),
})
export type LogEventRequest = z.infer<typeof LogEventRequestSchema>

export const LogEventResponseSchema = z.object({
	id: z.string().openapi({
		description: "Generated event ID",
		example: "event-abc123",
	}),
	rawRef: z.string().nullable().openapi({
		description: "Reference to stored raw content artifact",
		example: "artifact-raw-001",
	}),
	summaryRef: z.string().nullable().openapi({
		description: "Reference to stored summary artifact",
		example: "artifact-summary-001",
	}),
	embeddingId: z.string().nullable().openapi({
		description: "ID of generated embedding",
		example: "emb-001",
	}),
})
export type LogEventResponse = z.infer<typeof LogEventResponseSchema>

// ============================================================================
// store_artifact API
// ============================================================================

export const StoreArtifactRequestSchema = z.object({
	protocolId: z.string().openapi({
		description: "Protocol identifier",
		example: "uniswap-v3",
	}),
	seasonId: z.string().openapi({
		description: "Season identifier",
		example: "uniswap-v3:season-20241205-abc123",
	}),
	kind: ArtifactKindEnum.openapi({
		description: "Type of artifact",
		example: "source",
	}),
	raw: z.string().optional().openapi({
		description: "Raw content to store",
		example: "contract Test { function test() public {} }",
	}),
	summary: z.string().optional().openapi({
		description: "Summary of the content",
		example: "Simple test contract with one function",
	}),
	metadata: z
		.record(z.union([z.string(), z.number(), z.boolean()]))
		.optional()
		.openapi({
			description: "Additional metadata",
			example: { contract: "UniswapV3Pool", severity: "critical" },
		}),

	// Optional pre-computed embedding
	embedding: z.array(z.number()).optional().openapi({
		description: "Pre-computed embedding vector",
	}),
	embeddingModel: z.string().optional().openapi({
		description: "Model used for embedding",
		example: "text-embedding-3-small",
	}),

	// Retention
	retainDays: z.number().optional().default(30).openapi({
		description: "Number of days to retain the artifact",
		example: 30,
	}),
})
export type StoreArtifactRequest = z.infer<typeof StoreArtifactRequestSchema>

export const StoreArtifactResponseSchema = z.object({
	id: z.string().openapi({
		description: "Generated artifact ID",
		example: "artifact-001",
	}),
	embeddingId: z.string().nullable().openapi({
		description: "ID of generated embedding",
		example: "emb-001",
	}),
	rawHash: z.string().nullable().openapi({
		description: "Hash of the raw content for deduplication",
		example: "sha256-abc123",
	}),
})
export type StoreArtifactResponse = z.infer<typeof StoreArtifactResponseSchema>

// ============================================================================
// retrieve API
// ============================================================================

export const RetrieveFiltersSchema = z.object({
	phase: PhaseEnum.optional().openapi({
		description: "Filter by phase",
		example: "violation",
	}),
	contract: z.string().optional().openapi({
		description: "Filter by contract address or name",
		example: "0x1234",
	}),
	function: z.string().optional().openapi({
		description: "Filter by function name",
		example: "swap",
	}),
	invariantId: z.string().optional().openapi({
		description: "Filter by invariant ID",
		example: "inv-001",
	}),
	pathId: z.string().optional().openapi({
		description: "Filter by path ID",
		example: "path-001",
	}),
	scenarioId: z.string().optional().openapi({
		description: "Filter by scenario ID",
		example: "scenario-001",
	}),
	testId: z.string().optional().openapi({
		description: "Filter by test ID",
		example: "test-001",
	}),
	tool: z.string().optional().openapi({
		description: "Filter by tool name",
		example: "etherscan_fetch_source",
	}),
	kind: ArtifactKindEnum.optional().openapi({
		description: "Filter by artifact kind",
		example: "invariant",
	}),

	// Recency filter
	createdAfter: z.coerce.date().optional().openapi({
		description: "Filter artifacts created after this date",
		example: "2024-12-01T00:00:00Z",
	}),
	createdBefore: z.coerce.date().optional().openapi({
		description: "Filter artifacts created before this date",
		example: "2024-12-31T23:59:59Z",
	}),
})
export type RetrieveFilters = z.infer<typeof RetrieveFiltersSchema>

export const RetrieveRequestSchema = z.object({
	protocolId: z.string().openapi({
		description: "Protocol identifier",
		example: "uniswap-v3",
	}),
	seasonId: z.string().openapi({
		description: "Season identifier",
		example: "uniswap-v3:season-20241205-abc123",
	}),
	query: z.string().openapi({
		description: "Semantic search query",
		example: "flash loan vulnerability in swap function",
	}),

	// Filters
	filters: RetrieveFiltersSchema.optional().openapi({
		description: "Optional filters to narrow results",
	}),

	// Pagination
	limit: z
		.number()
		.min(1)
		.max(100)
		.default(10)
		.openapi({
			description: "Maximum number of results to return",
			example: 10,
			minimum: 1,
			maximum: 100,
		}),
	offset: z
		.number()
		.min(0)
		.default(0)
		.openapi({
			description: "Number of results to skip",
			example: 0,
			minimum: 0,
		}),

	// Options
	includeSummary: z.boolean().default(true).openapi({
		description: "Include summary in results",
		example: true,
	}),
	includeRaw: z.boolean().default(false).openapi({
		description: "Include raw content in results",
		example: false,
	}),
	threshold: z
		.number()
		.min(0)
		.max(1)
		.default(0.5)
		.openapi({
			description: "Similarity threshold for results",
			example: 0.5,
			minimum: 0,
			maximum: 1,
		}),
})
export type RetrieveRequest = z.infer<typeof RetrieveRequestSchema>

export const RetrieveResultSchema = z.object({
	id: z.string().openapi({
		description: "Artifact ID",
		example: "artifact-001",
	}),
	kind: ArtifactKindEnum.openapi({
		description: "Type of artifact",
		example: "invariant",
	}),
	summary: z.string().nullable().openapi({
		description: "Summary of the artifact",
		example: "Constant product invariant for swap function",
	}),
	raw: z.string().nullable().openapi({
		description: "Raw content (if requested)",
		example: null,
	}),
	similarity: z.number().openapi({
		description: "Similarity score",
		example: 0.85,
		minimum: 0,
		maximum: 1,
	}),
	metadata: z.record(z.unknown()).nullable().openapi({
		description: "Artifact metadata",
		example: { contract: "Pool", severity: "critical" },
	}),
	createdAt: z.coerce.date().openapi({
		description: "Creation timestamp",
		example: "2024-12-05T10:00:00Z",
	}),
})
export type RetrieveResult = z.infer<typeof RetrieveResultSchema>

export const RetrieveResponseSchema = z.object({
	results: z.array(RetrieveResultSchema).openapi({
		description: "Matching results",
	}),
	total: z.number().openapi({
		description: "Total number of matching results",
		example: 25,
	}),
	timing: z.number().openapi({
		description: "Query execution time in milliseconds",
		example: 150,
	}),
})
export type RetrieveResponse = z.infer<typeof RetrieveResponseSchema>

// ============================================================================
// similar API (for dedup/novelty)
// ============================================================================

export const SimilarRequestSchema = z.object({
	protocolId: z.string().openapi({
		description: "Protocol identifier",
		example: "uniswap-v3",
	}),
	seasonId: z.string().openapi({
		description: "Season identifier",
		example: "uniswap-v3:season-20241205-abc123",
	}),
	kind: ArtifactKindEnum.openapi({
		description: "Type of artifact to check against",
		example: "hypothesis",
	}),

	// One of these required
	text: z.string().optional().openapi({
		description: "Text to check for similarity",
		example: "Flash loan attack on swap function",
	}),
	embedding: z.array(z.number()).optional().openapi({
		description: "Pre-computed embedding to check",
	}),

	threshold: z
		.number()
		.min(0)
		.max(1)
		.default(0.85)
		.openapi({
			description: "Similarity threshold for duplicate detection",
			example: 0.85,
			minimum: 0,
			maximum: 1,
		}),
	limit: z
		.number()
		.min(1)
		.max(50)
		.default(5)
		.openapi({
			description: "Maximum number of similar items to return",
			example: 5,
			minimum: 1,
			maximum: 50,
		}),
})
export type SimilarRequest = z.infer<typeof SimilarRequestSchema>

export const SimilarResultSchema = z.object({
	id: z.string().openapi({
		description: "ID of similar artifact",
		example: "artifact-001",
	}),
	similarity: z.number().openapi({
		description: "Similarity score",
		example: 0.92,
		minimum: 0,
		maximum: 1,
	}),
	summary: z.string().nullable().openapi({
		description: "Summary of similar artifact",
		example: "Flash loan exploit targeting swap to drain liquidity",
	}),
	metadata: z.record(z.unknown()).nullable().openapi({
		description: "Artifact metadata",
	}),
})
export type SimilarResult = z.infer<typeof SimilarResultSchema>

export const SimilarResponseSchema = z.object({
	results: z.array(SimilarResultSchema).openapi({
		description: "Similar artifacts found",
	}),
	isDuplicate: z.boolean().openapi({
		description: "True if any result exceeds threshold",
		example: true,
	}),
	maxSimilarity: z.number().openapi({
		description: "Maximum similarity found",
		example: 0.92,
		minimum: 0,
		maximum: 1,
	}),
})
export type SimilarResponse = z.infer<typeof SimilarResponseSchema>

// ============================================================================
// link API
// ============================================================================

export const LinkRequestSchema = z.object({
	protocolId: z.string().openapi({
		description: "Protocol identifier",
		example: "uniswap-v3",
	}),
	seasonId: z.string().openapi({
		description: "Season identifier",
		example: "uniswap-v3:season-20241205-abc123",
	}),
	parentId: z.string().openapi({
		description: "Parent entity ID",
		example: "inv-001",
	}),
	childId: z.string().openapi({
		description: "Child entity ID",
		example: "path-001",
	}),
	relation: ExploitRelationEnum.openapi({
		description: "Type of relationship",
		example: "violates",
	}),
	confidence: z
		.number()
		.min(0)
		.max(1)
		.optional()
		.openapi({
			description: "Confidence score for the relationship",
			example: 0.9,
		}),
	notes: z.string().optional().openapi({
		description: "Notes about the relationship",
		example: "Path exploits invariant via price manipulation",
	}),
})
export type LinkRequest = z.infer<typeof LinkRequestSchema>

export const LinkResponseSchema = z.object({
	id: z.string().openapi({
		description: "Generated link ID",
		example: "link-001",
	}),
	success: z.boolean().openapi({
		description: "Whether the link was created successfully",
		example: true,
	}),
})
export type LinkResponse = z.infer<typeof LinkResponseSchema>

// ============================================================================
// record_feedback API
// ============================================================================

export const RecordFeedbackRequestSchema = z.object({
	protocolId: z.string().openapi({
		description: "Protocol identifier",
		example: "uniswap-v3",
	}),
	seasonId: z.string().openapi({
		description: "Season identifier",
		example: "uniswap-v3:season-20241205-abc123",
	}),
	testId: z.string().openapi({
		description: "Test ID that produced the feedback",
		example: "test-001",
	}),
	status: TestStatusEnum.openapi({
		description: "Result status of the test",
		example: "pass",
	}),

	// Details
	profit: z.number().optional().openapi({
		description: "Profit amount in USD",
		example: 125000,
	}),
	revertReason: z.string().optional().openapi({
		description: "Revert reason if test failed",
		example: "STF",
	}),
	failureDetails: z.string().optional().openapi({
		description: "Detailed failure description",
		example: "Insufficient liquidity in pool",
	}),

	// Linked entities to update
	linkedPathId: z.string().optional().openapi({
		description: "Path ID to update with feedback",
		example: "path-001",
	}),
	linkedScenarioId: z.string().optional().openapi({
		description: "Scenario ID to update with feedback",
		example: "scenario-001",
	}),
	linkedInvariantIds: z.array(z.string()).optional().openapi({
		description: "Invariant IDs to update with feedback",
		example: ["inv-001", "inv-002"],
	}),

	// Forge logs content
	forgeLogsContent: z.string().optional().openapi({
		description: "Raw forge test output",
		example: "[PASS] testExploit (1.5s)\nProfit: 125000 USDC",
	}),
})
export type RecordFeedbackRequest = z.infer<typeof RecordFeedbackRequestSchema>

export const UpdatedEntitySchema = z.object({
	id: z.string().openapi({
		description: "Updated entity ID",
		example: "path-001",
	}),
	type: z.string().openapi({
		description: "Entity type",
		example: "path",
	}),
	field: z.string().openapi({
		description: "Updated field name",
		example: "confirmedCount",
	}),
	oldValue: z.unknown().openapi({
		description: "Previous value",
		example: 0,
	}),
	newValue: z.unknown().openapi({
		description: "New value",
		example: 1,
	}),
})
export type UpdatedEntity = z.infer<typeof UpdatedEntitySchema>

export const RecordFeedbackResponseSchema = z.object({
	id: z.string().openapi({
		description: "Generated feedback ID",
		example: "feedback-001",
	}),
	updatedEntities: z.array(UpdatedEntitySchema).openapi({
		description: "Entities that were updated based on feedback",
	}),
})
export type RecordFeedbackResponse = z.infer<typeof RecordFeedbackResponseSchema>

// ============================================================================
// snapshot / restore API
// ============================================================================

export const SnapshotRequestSchema = z.object({
	seasonId: z.string().openapi({
		description: "Season ID to snapshot",
		example: "uniswap-v3:season-20241205-abc123",
	}),
	protocolId: z.string().openapi({
		description: "Protocol identifier",
		example: "uniswap-v3",
	}),
	metadata: z.record(z.unknown()).optional().openapi({
		description: "Additional metadata for the snapshot",
		example: { reason: "pre-refinement" },
	}),
})
export type SnapshotRequest = z.infer<typeof SnapshotRequestSchema>

export const SnapshotResponseSchema = z.object({
	id: z.string().openapi({
		description: "Generated snapshot ID",
		example: "snapshot-001",
	}),
	seasonId: z.string().openapi({
		description: "Season ID that was snapshotted",
		example: "uniswap-v3:season-20241205-abc123",
	}),
	createdAt: z.coerce.date().openapi({
		description: "Snapshot creation timestamp",
		example: "2024-12-05T15:00:00Z",
	}),
})
export type SnapshotResponse = z.infer<typeof SnapshotResponseSchema>

export const RestoreRequestSchema = z.object({
	snapshotId: z.string().openapi({
		description: "Snapshot ID to restore from",
		example: "snapshot-001",
	}),
	protocolId: z.string().openapi({
		description: "Protocol identifier",
		example: "uniswap-v3",
	}),
})
export type RestoreRequest = z.infer<typeof RestoreRequestSchema>

export const RestoreResponseSchema = z.object({
	success: z.boolean().openapi({
		description: "Whether the restore was successful",
		example: true,
	}),
	restoredSeasonId: z.string().openapi({
		description: "ID of the restored season",
		example: "uniswap-v3:season-20241205-restored-xyz",
	}),
	restoredEntities: z
		.object({
			graphs: z.number().openapi({ example: 1 }),
			invariants: z.number().openapi({ example: 20 }),
			paths: z.number().openapi({ example: 10 }),
			scenarios: z.number().openapi({ example: 5 }),
			tests: z.number().openapi({ example: 3 }),
		})
		.openapi({
			description: "Count of restored entities by type",
		}),
})
export type RestoreResponse = z.infer<typeof RestoreResponseSchema>

// ============================================================================
// Season Management
// ============================================================================

export const CreateSeasonRequestSchema = z.object({
	protocolId: z.string().openapi({
		description: "Protocol identifier to create season for",
		example: "uniswap-v3",
	}),
	metadata: z.record(z.unknown()).optional().openapi({
		description: "Additional metadata for the season",
		example: { purpose: "mainnet audit" },
	}),
})
export type CreateSeasonRequest = z.infer<typeof CreateSeasonRequestSchema>

export const CreateSeasonResponseSchema = z.object({
	id: z.string().openapi({
		description: "Generated season ID",
		example: "uniswap-v3:season-20241205-abc123",
	}),
	protocolId: z.string().openapi({
		description: "Protocol identifier",
		example: "uniswap-v3",
	}),
	status: SeasonStatusEnum.openapi({
		description: "Initial season status",
		example: "active",
	}),
	createdAt: z.coerce.date().openapi({
		description: "Season creation timestamp",
		example: "2024-12-05T10:00:00Z",
	}),
})
export type CreateSeasonResponse = z.infer<typeof CreateSeasonResponseSchema>

export const CloseSeasonRequestSchema = z.object({
	seasonId: z.string().openapi({
		description: "Season ID to close",
		example: "uniswap-v3:season-20241205-abc123",
	}),
	protocolId: z.string().openapi({
		description: "Protocol identifier",
		example: "uniswap-v3",
	}),
})
export type CloseSeasonRequest = z.infer<typeof CloseSeasonRequestSchema>

export const CloseSeasonResponseSchema = z.object({
	success: z.boolean().openapi({
		description: "Whether the close was successful",
		example: true,
	}),
	finalSnapshot: z.string().nullable().openapi({
		description: "ID of the final snapshot created before closing",
		example: "snapshot-final-001",
	}),
})
export type CloseSeasonResponse = z.infer<typeof CloseSeasonResponseSchema>

// ============================================================================
// Import API (admin only)
// ============================================================================

export const ImportSummariesRequestSchema = z.object({
	targetSeasonId: z.string().openapi({
		description: "Season ID to import into",
		example: "uniswap-v3:season-20241210-new",
	}),
	sourceSeasonId: z.string().openapi({
		description: "Season ID to import from",
		example: "uniswap-v3:season-20241205-abc123",
	}),
	protocolId: z.string().openapi({
		description: "Protocol identifier",
		example: "uniswap-v3",
	}),

	// What to import
	importInvariants: z.boolean().default(true).openapi({
		description: "Import invariants from source season",
		example: true,
	}),
	importPaths: z.boolean().default(false).openapi({
		description: "Import paths from source season",
		example: false,
	}),
	importQuestions: z.boolean().default(true).openapi({
		description: "Import questions from source season",
		example: true,
	}),

	// Filter
	minConfidence: z
		.number()
		.min(0)
		.max(1)
		.default(0.7)
		.openapi({
			description: "Minimum confidence threshold for import",
			example: 0.7,
		}),
})
export type ImportSummariesRequest = z.infer<typeof ImportSummariesRequestSchema>

export const ImportSummariesResponseSchema = z.object({
	imported: z
		.object({
			invariants: z.number().openapi({ example: 15 }),
			paths: z.number().openapi({ example: 0 }),
			questions: z.number().openapi({ example: 10 }),
		})
		.openapi({
			description: "Count of imported entities by type",
		}),
})
export type ImportSummariesResponse = z.infer<typeof ImportSummariesResponseSchema>

// ============================================================================
// Error Response
// ============================================================================

export const ExploitResearchErrorSchema = z.object({
	error: z.string().openapi({
		description: "Error message",
		example: "Season not found",
	}),
	code: z.string().optional().openapi({
		description: "Error code",
		example: "SEASON_NOT_FOUND",
	}),
	details: z.record(z.unknown()).optional().openapi({
		description: "Additional error details",
	}),
})
export type ExploitResearchError = z.infer<typeof ExploitResearchErrorSchema>

// ============================================================================
// EXPORTS
// ============================================================================

export const exploitResearchApiSchemas = {
	// Log Event
	LogEventRequestSchema,
	LogEventResponseSchema,

	// Store Artifact
	StoreArtifactRequestSchema,
	StoreArtifactResponseSchema,

	// Retrieve
	RetrieveFiltersSchema,
	RetrieveRequestSchema,
	RetrieveResultSchema,
	RetrieveResponseSchema,

	// Similar
	SimilarRequestSchema,
	SimilarResultSchema,
	SimilarResponseSchema,

	// Link
	LinkRequestSchema,
	LinkResponseSchema,

	// Feedback
	RecordFeedbackRequestSchema,
	UpdatedEntitySchema,
	RecordFeedbackResponseSchema,

	// Snapshot/Restore
	SnapshotRequestSchema,
	SnapshotResponseSchema,
	RestoreRequestSchema,
	RestoreResponseSchema,

	// Season Management
	CreateSeasonRequestSchema,
	CreateSeasonResponseSchema,
	CloseSeasonRequestSchema,
	CloseSeasonResponseSchema,

	// Import
	ImportSummariesRequestSchema,
	ImportSummariesResponseSchema,

	// Error
	ExploitResearchErrorSchema,
} as const
