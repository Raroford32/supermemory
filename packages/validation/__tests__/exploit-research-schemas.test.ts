import { describe, it, expect } from "vitest"
import {
	PhaseEnum,
	SeasonStatusEnum,
	ArtifactKindEnum,
	InvariantCategoryEnum,
	TestStatusEnum,
	ExploitRelationEnum,
	SeverityEnum,
	ProtocolSchema,
	SeasonSchema,
	SeasonCoverageSchema,
	ContractSchema,
	GraphSchema,
	InvariantSchema,
	PathStepSchema,
	PathSchema,
	ScenarioSchema,
	TestSchema,
	ExecutionSchema,
	ToolEventSchema,
	ArtifactSchema,
	QuestionSchema,
	EntityRelationSchema,
	FeedbackSchema,
	SeasonSnapshotSchema,
} from "../exploit-research-schemas"

describe("Exploit Research Schemas", () => {
	describe("PhaseEnum", () => {
		it("should validate all 7 phases", () => {
			const phases = [
				"intake",
				"graphing",
				"invariant",
				"violation",
				"poc_generation",
				"execution",
				"refinement",
			]
			for (const phase of phases) {
				expect(() => PhaseEnum.parse(phase)).not.toThrow()
			}
		})

		it("should reject invalid phases", () => {
			expect(() => PhaseEnum.parse("invalid")).toThrow()
			expect(() => PhaseEnum.parse("")).toThrow()
		})
	})

	describe("SeasonStatusEnum", () => {
		it("should validate all status values", () => {
			const statuses = ["created", "active", "paused", "closed"]
			for (const status of statuses) {
				expect(() => SeasonStatusEnum.parse(status)).not.toThrow()
			}
		})

		it("should reject invalid status", () => {
			expect(() => SeasonStatusEnum.parse("invalid")).toThrow()
		})
	})

	describe("ArtifactKindEnum", () => {
		it("should validate all 14 artifact kinds", () => {
			const kinds = [
				"source",
				"abi",
				"graph",
				"invariant",
				"path",
				"hypothesis",
				"scenario",
				"test",
				"execution",
				"log",
				"question",
				"forge_output",
				"contract_outline",
				"tool_output",
			]
			expect(ArtifactKindEnum.options).toHaveLength(14)
			for (const kind of kinds) {
				expect(() => ArtifactKindEnum.parse(kind)).not.toThrow()
			}
		})
	})

	describe("InvariantCategoryEnum", () => {
		it("should validate all 18 invariant categories", () => {
			const categories = [
				"access_control",
				"arithmetic",
				"reentrancy",
				"oracle_manipulation",
				"flash_loan",
				"price_manipulation",
				"slippage",
				"timestamp_dependency",
				"front_running",
				"governance",
				"liquidity",
				"collateral",
				"interest_rate",
				"liquidation",
				"fee_extraction",
				"donation_attack",
				"first_depositor",
				"custom",
			]
			expect(InvariantCategoryEnum.options).toHaveLength(18)
			for (const cat of categories) {
				expect(() => InvariantCategoryEnum.parse(cat)).not.toThrow()
			}
		})
	})

	describe("TestStatusEnum", () => {
		it("should validate all test statuses", () => {
			const statuses = [
				"pending",
				"running",
				"pass",
				"fail",
				"flaky",
				"inconclusive",
				"error",
			]
			for (const status of statuses) {
				expect(() => TestStatusEnum.parse(status)).not.toThrow()
			}
		})
	})

	describe("ExploitRelationEnum", () => {
		it("should validate all 10 relation types", () => {
			const relations = [
				"derived_from",
				"violates",
				"uses",
				"depends_on",
				"tested_by",
				"confirmed_by",
				"refutes",
				"updates",
				"extends",
				"derives",
			]
			expect(ExploitRelationEnum.options).toHaveLength(10)
			for (const rel of relations) {
				expect(() => ExploitRelationEnum.parse(rel)).not.toThrow()
			}
		})
	})

	describe("SeverityEnum", () => {
		it("should validate all severity levels", () => {
			const severities = [
				"critical",
				"high",
				"medium",
				"low",
				"informational",
			]
			for (const sev of severities) {
				expect(() => SeverityEnum.parse(sev)).not.toThrow()
			}
		})
	})

	describe("ProtocolSchema", () => {
		it("should validate a complete protocol", () => {
			const valid = {
				id: "uniswap-v3",
				name: "Uniswap V3",
				chains: ["ethereum", "arbitrum"],
				type: "dex",
				valueContracts: ["0x1234567890abcdef1234567890abcdef12345678"],
				criticalFunctions: [
					{
						contract: "Pool",
						function: "swap",
						signature: "swap(address,bool,int256,uint160,bytes)",
						risk: "high",
					},
				],
				seasonIds: [],
				createdAt: new Date(),
				updatedAt: new Date(),
			}
			expect(() => ProtocolSchema.parse(valid)).not.toThrow()
		})

		it("should reject missing required fields", () => {
			const invalid = { id: "test" }
			expect(() => ProtocolSchema.parse(invalid)).toThrow()
		})

		it("should accept optional metadata", () => {
			const valid = {
				id: "uniswap-v3",
				name: "Uniswap V3",
				chains: ["ethereum"],
				type: "dex",
				valueContracts: [],
				criticalFunctions: [],
				seasonIds: [],
				metadata: {
					version: "3.0",
					audited: true,
					tvl: 1000000000,
				},
				createdAt: new Date(),
				updatedAt: new Date(),
			}
			expect(() => ProtocolSchema.parse(valid)).not.toThrow()
		})
	})

	describe("SeasonCoverageSchema", () => {
		it("should use default values", () => {
			const result = SeasonCoverageSchema.parse({})
			expect(result.contractsAnalyzed).toBe(0)
			expect(result.functionsAnalyzed).toBe(0)
			expect(result.invariantsGenerated).toBe(0)
			expect(result.pathsExplored).toBe(0)
			expect(result.scenariosGenerated).toBe(0)
			expect(result.testsRun).toBe(0)
			expect(result.testsPassed).toBe(0)
			expect(result.testsFailed).toBe(0)
			expect(result.profitableExploits).toBe(0)
		})

		it("should accept custom values", () => {
			const coverage = {
				contractsAnalyzed: 5,
				functionsAnalyzed: 50,
				invariantsGenerated: 20,
				pathsExplored: 10,
				scenariosGenerated: 5,
				testsRun: 3,
				testsPassed: 2,
				testsFailed: 1,
				profitableExploits: 0,
			}
			const result = SeasonCoverageSchema.parse(coverage)
			expect(result.contractsAnalyzed).toBe(5)
			expect(result.functionsAnalyzed).toBe(50)
		})
	})

	describe("SeasonSchema", () => {
		it("should validate season with coverage", () => {
			const season = {
				id: "uniswap-v3:season-20241205-abc123",
				protocolId: "uniswap-v3",
				status: "active",
				startedAt: new Date(),
				coverage: {
					contractsAnalyzed: 5,
					functionsAnalyzed: 50,
					invariantsGenerated: 20,
					pathsExplored: 10,
					scenariosGenerated: 5,
					testsRun: 3,
					testsPassed: 2,
					testsFailed: 1,
					profitableExploits: 0,
				},
				activePhases: ["invariant", "violation"],
				createdAt: new Date(),
				updatedAt: new Date(),
			}
			expect(() => SeasonSchema.parse(season)).not.toThrow()
		})

		it("should enforce status enum values", () => {
			expect(() => SeasonStatusEnum.parse("invalid")).toThrow()
			expect(() => SeasonStatusEnum.parse("active")).not.toThrow()
		})

		it("should accept optional fields", () => {
			const season = {
				id: "test-season",
				protocolId: "test-protocol",
				status: "created",
				startedAt: new Date(),
				closedAt: null,
				coverage: {},
				activePhases: [],
				currentPhase: "intake",
				checkpointData: { lastPhase: "graphing" },
				createdAt: new Date(),
				updatedAt: new Date(),
			}
			expect(() => SeasonSchema.parse(season)).not.toThrow()
		})
	})

	describe("ContractSchema", () => {
		it("should validate a contract", () => {
			const contract = {
				id: "contract-001",
				protocolId: "uniswap-v3",
				seasonId: "uniswap-v3:season-20241205-abc123",
				address: "0x1234567890abcdef1234567890abcdef12345678",
				chain: "ethereum",
				name: "UniswapV3Pool",
				holdsValue: true,
				role: "vault",
				createdAt: new Date(),
				updatedAt: new Date(),
			}
			expect(() => ContractSchema.parse(contract)).not.toThrow()
		})

		it("should use default values", () => {
			const contract = {
				id: "contract-001",
				protocolId: "uniswap-v3",
				seasonId: "season-001",
				address: "0x1234",
				chain: "ethereum",
				name: "Test",
				createdAt: new Date(),
				updatedAt: new Date(),
			}
			const result = ContractSchema.parse(contract)
			expect(result.holdsValue).toBe(false)
		})
	})

	describe("GraphSchema", () => {
		it("should validate a graph", () => {
			const graph = {
				id: "graph-001",
				protocolId: "uniswap-v3",
				seasonId: "season-001",
				nodeCount: 50,
				edgeCount: 120,
				graphHash: "abc123def456",
				contractsCovered: ["contract-001", "contract-002"],
				coverage: 85,
				createdAt: new Date(),
				updatedAt: new Date(),
			}
			expect(() => GraphSchema.parse(graph)).not.toThrow()
		})
	})

	describe("InvariantSchema", () => {
		it("should validate invariant with embeddings", () => {
			const invariant = {
				id: "inv-001",
				protocolId: "uniswap-v3",
				seasonId: "uniswap-v3:season-20241205-abc123",
				category: "arithmetic",
				formula: "reserve0 * reserve1 >= k",
				description: "Constant product invariant",
				variables: ["reserve0", "reserve1", "k"],
				severity: "critical",
				confidence: 0.95,
				embedding: new Array(1536).fill(0.1),
				embeddingModel: "text-embedding-3-small",
				createdAt: new Date(),
				updatedAt: new Date(),
			}
			expect(() => InvariantSchema.parse(invariant)).not.toThrow()
		})

		it("should enforce confidence range 0-1", () => {
			expect(() =>
				InvariantSchema.shape.confidence.parse(1.5),
			).toThrow()
			expect(() =>
				InvariantSchema.shape.confidence.parse(-0.1),
			).toThrow()
			expect(() => InvariantSchema.shape.confidence.parse(0.5)).not.toThrow()
			expect(() => InvariantSchema.shape.confidence.parse(0)).not.toThrow()
			expect(() => InvariantSchema.shape.confidence.parse(1)).not.toThrow()
		})

		it("should validate all invariant categories", () => {
			const categories = [
				"access_control",
				"arithmetic",
				"reentrancy",
				"oracle_manipulation",
				"flash_loan",
				"price_manipulation",
				"slippage",
				"timestamp_dependency",
				"front_running",
				"governance",
				"liquidity",
				"collateral",
				"interest_rate",
				"liquidation",
				"fee_extraction",
				"donation_attack",
				"first_depositor",
				"custom",
			]
			for (const cat of categories) {
				expect(() => InvariantCategoryEnum.parse(cat)).not.toThrow()
			}
		})

		it("should use default values for status fields", () => {
			const invariant = {
				id: "inv-001",
				protocolId: "uniswap-v3",
				seasonId: "season-001",
				category: "arithmetic",
				formula: "x > 0",
				description: "Test invariant",
				variables: ["x"],
				severity: "high",
				confidence: 0.8,
				createdAt: new Date(),
				updatedAt: new Date(),
			}
			const result = InvariantSchema.parse(invariant)
			expect(result.isViolated).toBe(false)
			expect(result.violationCount).toBe(0)
		})
	})

	describe("PathStepSchema", () => {
		it("should validate a path step", () => {
			const step = {
				contract: "Pool",
				function: "swap",
				inputs: { amount0: "1000000", zeroForOne: true },
				expectedState: { reserve0: "decreased" },
				notes: "Initial swap to manipulate price",
			}
			expect(() => PathStepSchema.parse(step)).not.toThrow()
		})

		it("should allow minimal step", () => {
			const step = {
				contract: "Pool",
				function: "swap",
			}
			expect(() => PathStepSchema.parse(step)).not.toThrow()
		})
	})

	describe("PathSchema", () => {
		it("should validate path with steps", () => {
			const path = {
				id: "path-001",
				protocolId: "uniswap-v3",
				seasonId: "uniswap-v3:season-20241205-abc123",
				violatedInvariantId: "inv-001",
				steps: [
					{ contract: "Pool", function: "flash", inputs: { amount0: "1000000" } },
					{ contract: "Pool", function: "swap", inputs: { zeroForOne: true } },
				],
				estimatedProfit: 50000,
				confidence: 0.8,
				complexity: 5,
				assumptions: ["Sufficient liquidity"],
				preconditions: ["Block number > 18000000"],
				createdAt: new Date(),
				updatedAt: new Date(),
			}
			expect(() => PathSchema.parse(path)).not.toThrow()
		})

		it("should enforce complexity range 1-10", () => {
			expect(() => PathSchema.shape.complexity.parse(0)).toThrow()
			expect(() => PathSchema.shape.complexity.parse(11)).toThrow()
			expect(() => PathSchema.shape.complexity.parse(5)).not.toThrow()
			expect(() => PathSchema.shape.complexity.parse(1)).not.toThrow()
			expect(() => PathSchema.shape.complexity.parse(10)).not.toThrow()
		})

		it("should use default values", () => {
			const path = {
				id: "path-001",
				protocolId: "test",
				seasonId: "season-001",
				violatedInvariantId: "inv-001",
				steps: [],
				confidence: 0.5,
				complexity: 3,
				assumptions: [],
				preconditions: [],
				createdAt: new Date(),
				updatedAt: new Date(),
			}
			const result = PathSchema.parse(path)
			expect(result.isViable).toBe(true)
			expect(result.testedCount).toBe(0)
			expect(result.confirmedCount).toBe(0)
		})
	})

	describe("ScenarioSchema", () => {
		it("should validate a scenario with full economics", () => {
			const scenario = {
				id: "scenario-001",
				protocolId: "uniswap-v3",
				seasonId: "season-001",
				derivedFromPathId: "path-001",
				grossProfit: 100000,
				netProfit: 75000,
				gasCosts: 5000,
				flashLoanFees: 20000,
				requiredCapital: 1000000,
				contractsInvolved: ["contract-001", "contract-002"],
				confidence: 0.85,
				complexity: 7,
				createdAt: new Date(),
				updatedAt: new Date(),
			}
			expect(() => ScenarioSchema.parse(scenario)).not.toThrow()
		})
	})

	describe("TestSchema", () => {
		it("should validate all test statuses", () => {
			const statuses = [
				"pending",
				"running",
				"pass",
				"fail",
				"flaky",
				"inconclusive",
				"error",
			]
			for (const status of statuses) {
				expect(() => TestStatusEnum.parse(status)).not.toThrow()
			}
		})

		it("should validate a test", () => {
			const test = {
				id: "test-001",
				protocolId: "uniswap-v3",
				seasonId: "season-001",
				scenarioId: "scenario-001",
				codeHash: "abc123",
				status: "pending",
				forkRpc: "https://eth-mainnet.alchemyapi.io/v2/xxx",
				forkBlock: 18000000,
				createdAt: new Date(),
				updatedAt: new Date(),
			}
			expect(() => TestSchema.parse(test)).not.toThrow()
		})
	})

	describe("ExecutionSchema", () => {
		it("should validate an execution", () => {
			const execution = {
				id: "exec-001",
				protocolId: "uniswap-v3",
				seasonId: "season-001",
				testId: "test-001",
				status: "pass",
				profit: 50000,
				forkRpc: "https://eth-mainnet.alchemyapi.io/v2/xxx",
				forkBlock: 18000000,
				gasUsed: 500000,
				executionTime: 1500,
				createdAt: new Date(),
			}
			expect(() => ExecutionSchema.parse(execution)).not.toThrow()
		})

		it("should validate failed execution with revert reason", () => {
			const execution = {
				id: "exec-002",
				protocolId: "uniswap-v3",
				seasonId: "season-001",
				testId: "test-001",
				status: "fail",
				failureReason: "Insufficient liquidity",
				revertReason: "STF",
				forkRpc: "https://eth-mainnet.alchemyapi.io/v2/xxx",
				forkBlock: 18000000,
				createdAt: new Date(),
			}
			expect(() => ExecutionSchema.parse(execution)).not.toThrow()
		})
	})

	describe("ToolEventSchema", () => {
		it("should validate a tool event", () => {
			const event = {
				id: "tool-001",
				protocolId: "uniswap-v3",
				seasonId: "season-001",
				phase: "invariant",
				toolName: "etherscan_fetch_source",
				toolCallId: "call_xyz789",
				targetContract: "0x1234",
				success: true,
				duration: 1250,
				inputTokens: 100,
				outputTokens: 500,
				costUsd: 0.01,
				createdAt: new Date(),
			}
			expect(() => ToolEventSchema.parse(event)).not.toThrow()
		})
	})

	describe("ArtifactSchema", () => {
		it("should validate an artifact", () => {
			const artifact = {
				id: "artifact-001",
				protocolId: "uniswap-v3",
				seasonId: "season-001",
				kind: "source",
				raw: "// SPDX-License-Identifier: MIT\ncontract Test {}",
				rawHash: "abc123",
				summary: "Simple test contract",
				rawSize: 1000,
				summarySize: 100,
				createdAt: new Date(),
				updatedAt: new Date(),
			}
			expect(() => ArtifactSchema.parse(artifact)).not.toThrow()
		})

		it("should validate all artifact kinds", () => {
			const kinds = [
				"source",
				"abi",
				"graph",
				"invariant",
				"path",
				"hypothesis",
				"scenario",
				"test",
				"execution",
				"log",
				"question",
				"forge_output",
				"contract_outline",
				"tool_output",
			]
			for (const kind of kinds) {
				expect(() => ArtifactKindEnum.parse(kind)).not.toThrow()
			}
		})
	})

	describe("QuestionSchema", () => {
		it("should validate a question", () => {
			const question = {
				id: "question-001",
				protocolId: "uniswap-v3",
				seasonId: "season-001",
				text: "What happens when the pool is manipulated?",
				category: "price_manipulation",
				successRate: 0.7,
				timesAsked: 5,
				linkedInvariantId: "inv-001",
				createdAt: new Date(),
				updatedAt: new Date(),
			}
			expect(() => QuestionSchema.parse(question)).not.toThrow()
		})

		it("should use default values", () => {
			const question = {
				id: "question-001",
				protocolId: "test",
				seasonId: "season-001",
				text: "Test question",
				createdAt: new Date(),
				updatedAt: new Date(),
			}
			const result = QuestionSchema.parse(question)
			expect(result.successRate).toBe(0)
			expect(result.timesAsked).toBe(0)
		})
	})

	describe("EntityRelationSchema", () => {
		it("should validate an entity relation", () => {
			const relation = {
				id: "rel-001",
				parentId: "inv-001",
				childId: "path-001",
				relation: "violates",
				protocolId: "uniswap-v3",
				seasonId: "season-001",
				confidence: 0.9,
				notes: "Path exploits invariant",
				createdAt: new Date(),
			}
			expect(() => EntityRelationSchema.parse(relation)).not.toThrow()
		})

		it("should validate all relation types", () => {
			const relations = [
				"derived_from",
				"violates",
				"uses",
				"depends_on",
				"tested_by",
				"confirmed_by",
				"refutes",
				"updates",
				"extends",
				"derives",
			]
			for (const rel of relations) {
				expect(() => ExploitRelationEnum.parse(rel)).not.toThrow()
			}
		})
	})

	describe("FeedbackSchema", () => {
		it("should validate feedback", () => {
			const feedback = {
				id: "feedback-001",
				protocolId: "uniswap-v3",
				seasonId: "season-001",
				testId: "test-001",
				status: "pass",
				profit: 125000,
				linkedPathId: "path-001",
				linkedScenarioId: "scenario-001",
				linkedInvariantIds: ["inv-001", "inv-002"],
				forgeLogsRef: "artifact-logs-001",
				createdAt: new Date(),
			}
			expect(() => FeedbackSchema.parse(feedback)).not.toThrow()
		})

		it("should validate failed feedback with details", () => {
			const feedback = {
				id: "feedback-002",
				protocolId: "uniswap-v3",
				seasonId: "season-001",
				testId: "test-001",
				status: "fail",
				revertReason: "STF",
				failureDetails: "Insufficient token balance for swap",
				createdAt: new Date(),
			}
			expect(() => FeedbackSchema.parse(feedback)).not.toThrow()
		})
	})

	describe("SeasonSnapshotSchema", () => {
		it("should validate a season snapshot", () => {
			const snapshot = {
				id: "snapshot-001",
				seasonId: "season-001",
				protocolId: "uniswap-v3",
				coverage: {
					contractsAnalyzed: 5,
					functionsAnalyzed: 50,
					invariantsGenerated: 20,
					pathsExplored: 10,
					scenariosGenerated: 5,
					testsRun: 3,
					testsPassed: 2,
					testsFailed: 1,
					profitableExploits: 0,
				},
				activePhases: ["invariant", "violation"],
				currentPhase: "violation",
				activeGraphIds: ["graph-001"],
				activeInvariantIds: ["inv-001", "inv-002"],
				activePathIds: ["path-001"],
				activeScenarioIds: ["scenario-001"],
				activeTestIds: ["test-001"],
				checkpointData: { lastSavedAt: new Date().toISOString() },
				createdAt: new Date(),
			}
			expect(() => SeasonSnapshotSchema.parse(snapshot)).not.toThrow()
		})
	})
})
