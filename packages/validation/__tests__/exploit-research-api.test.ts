import { describe, it, expect } from "vitest"
import {
	LogEventRequestSchema,
	LogEventResponseSchema,
	StoreArtifactRequestSchema,
	StoreArtifactResponseSchema,
	RetrieveRequestSchema,
	RetrieveResponseSchema,
	RetrieveResultSchema,
	SimilarRequestSchema,
	SimilarResponseSchema,
	LinkRequestSchema,
	LinkResponseSchema,
	RecordFeedbackRequestSchema,
	RecordFeedbackResponseSchema,
	SnapshotRequestSchema,
	SnapshotResponseSchema,
	RestoreRequestSchema,
	RestoreResponseSchema,
	CreateSeasonRequestSchema,
	CreateSeasonResponseSchema,
	CloseSeasonRequestSchema,
	CloseSeasonResponseSchema,
	ImportSummariesRequestSchema,
	ImportSummariesResponseSchema,
	ExploitResearchErrorSchema,
} from "../exploit-research-api"

describe("Exploit Research API Schemas", () => {
	describe("LogEventRequestSchema", () => {
		it("should validate complete log event", () => {
			const event = {
				protocolId: "uniswap-v3",
				seasonId: "uniswap-v3:season-20241205-abc123",
				phase: "invariant",
				toolName: "etherscan_fetch_source",
				toolCallId: "call_xyz789",
				success: true,
				duration: 1250,
				rawContent: "// SPDX-License-Identifier...",
			}
			expect(() => LogEventRequestSchema.parse(event)).not.toThrow()
		})

		it("should require protocolId, seasonId, phase, toolName, toolCallId, success", () => {
			const invalid = { toolName: "test", success: true }
			expect(() => LogEventRequestSchema.parse(invalid)).toThrow()
		})

		it("should validate with all optional fields", () => {
			const event = {
				protocolId: "uniswap-v3",
				seasonId: "uniswap-v3:season-20241205-abc123",
				phase: "execution",
				toolName: "forge_test",
				toolCallId: "call_abc",
				success: false,
				duration: 5000,
				targetContract: "0x1234",
				targetFunction: "swap",
				targetInvariantId: "inv-001",
				targetPathId: "path-001",
				targetTestId: "test-001",
				inputTokens: 100,
				outputTokens: 500,
				costUsd: 0.01,
				rawContent: "Test output...",
				summaryContent: "Test failed",
				metadata: { error: "revert" },
			}
			expect(() => LogEventRequestSchema.parse(event)).not.toThrow()
		})

		it("should validate phase enum", () => {
			const baseEvent = {
				protocolId: "test",
				seasonId: "test:season-001",
				toolName: "test",
				toolCallId: "call_001",
				success: true,
			}

			const validPhases = [
				"intake",
				"graphing",
				"invariant",
				"violation",
				"poc_generation",
				"execution",
				"refinement",
			]

			for (const phase of validPhases) {
				expect(() =>
					LogEventRequestSchema.parse({ ...baseEvent, phase }),
				).not.toThrow()
			}

			expect(() =>
				LogEventRequestSchema.parse({ ...baseEvent, phase: "invalid" }),
			).toThrow()
		})
	})

	describe("LogEventResponseSchema", () => {
		it("should validate response with all fields", () => {
			const response = {
				id: "event-123",
				rawRef: "artifact-raw-001",
				summaryRef: "artifact-summary-001",
				embeddingId: "emb-001",
			}
			expect(() => LogEventResponseSchema.parse(response)).not.toThrow()
		})

		it("should allow null references", () => {
			const response = {
				id: "event-123",
				rawRef: null,
				summaryRef: null,
				embeddingId: null,
			}
			expect(() => LogEventResponseSchema.parse(response)).not.toThrow()
		})
	})

	describe("StoreArtifactRequestSchema", () => {
		it("should validate with minimal required fields", () => {
			const request = {
				protocolId: "uniswap-v3",
				seasonId: "season-001",
				kind: "source",
			}
			expect(() => StoreArtifactRequestSchema.parse(request)).not.toThrow()
		})

		it("should validate with all fields", () => {
			const request = {
				protocolId: "uniswap-v3",
				seasonId: "season-001",
				kind: "invariant",
				raw: '{"category":"arithmetic","formula":"x > 0"}',
				summary: "Arithmetic invariant",
				metadata: { severity: "critical" },
				embedding: new Array(1536).fill(0.1),
				embeddingModel: "text-embedding-3-small",
				retainDays: 60,
			}
			expect(() => StoreArtifactRequestSchema.parse(request)).not.toThrow()
		})

		it("should use default retainDays", () => {
			const request = {
				protocolId: "uniswap-v3",
				seasonId: "season-001",
				kind: "source",
			}
			const result = StoreArtifactRequestSchema.parse(request)
			expect(result.retainDays).toBe(30)
		})

		it("should validate all artifact kinds", () => {
			const kinds = [
				"source",
				"abi",
				"graph",
				"invariant",
				"path",
				"hypothesis",
				"scenario",
				"test",
				"execution",
				"log",
				"question",
				"forge_output",
				"contract_outline",
				"tool_output",
			]

			for (const kind of kinds) {
				const request = {
					protocolId: "test",
					seasonId: "season-001",
					kind,
				}
				expect(() => StoreArtifactRequestSchema.parse(request)).not.toThrow()
			}
		})
	})

	describe("RetrieveRequestSchema", () => {
		it("should validate with minimal fields", () => {
			const request = {
				protocolId: "uniswap-v3",
				seasonId: "season-001",
				query: "flash loan vulnerability",
			}
			expect(() => RetrieveRequestSchema.parse(request)).not.toThrow()
		})

		it("should validate with filters", () => {
			const request = {
				protocolId: "uniswap-v3",
				seasonId: "uniswap-v3:season-20241205-abc123",
				query: "flash loan vulnerability",
				filters: {
					phase: "violation",
					contract: "Pool",
					createdAfter: new Date("2024-12-01"),
				},
				limit: 20,
				threshold: 0.6,
			}
			expect(() => RetrieveRequestSchema.parse(request)).not.toThrow()
		})

		it("should enforce limit bounds", () => {
			const base = {
				protocolId: "test",
				seasonId: "season-001",
				query: "test",
			}

			expect(() =>
				RetrieveRequestSchema.parse({ ...base, limit: 0 }),
			).toThrow()
			expect(() =>
				RetrieveRequestSchema.parse({ ...base, limit: 101 }),
			).toThrow()
			expect(() =>
				RetrieveRequestSchema.parse({ ...base, limit: 50 }),
			).not.toThrow()
		})

		it("should enforce threshold bounds", () => {
			const base = {
				protocolId: "test",
				seasonId: "season-001",
				query: "test",
			}

			expect(() =>
				RetrieveRequestSchema.parse({ ...base, threshold: -0.1 }),
			).toThrow()
			expect(() =>
				RetrieveRequestSchema.parse({ ...base, threshold: 1.1 }),
			).toThrow()
			expect(() =>
				RetrieveRequestSchema.parse({ ...base, threshold: 0.75 }),
			).not.toThrow()
		})

		it("should use default values", () => {
			const request = {
				protocolId: "test",
				seasonId: "season-001",
				query: "test",
			}
			const result = RetrieveRequestSchema.parse(request)
			expect(result.limit).toBe(10)
			expect(result.offset).toBe(0)
			expect(result.includeSummary).toBe(true)
			expect(result.includeRaw).toBe(false)
			expect(result.threshold).toBe(0.5)
		})
	})

	describe("RetrieveResponseSchema", () => {
		it("should validate response with results", () => {
			const response = {
				results: [
					{
						id: "artifact-001",
						kind: "invariant",
						summary: "Constant product invariant",
						raw: null,
						similarity: 0.85,
						metadata: { severity: "critical" },
						createdAt: new Date(),
					},
				],
				total: 1,
				timing: 150,
			}
			expect(() => RetrieveResponseSchema.parse(response)).not.toThrow()
		})

		it("should validate empty results", () => {
			const response = {
				results: [],
				total: 0,
				timing: 50,
			}
			expect(() => RetrieveResponseSchema.parse(response)).not.toThrow()
		})
	})

	describe("SimilarRequestSchema", () => {
		it("should accept text for dedup check", () => {
			const request = {
				protocolId: "uniswap-v3",
				seasonId: "uniswap-v3:season-20241205-abc123",
				kind: "hypothesis",
				text: "Flash loan attack on swap function",
				threshold: 0.85,
			}
			expect(() => SimilarRequestSchema.parse(request)).not.toThrow()
		})

		it("should accept embedding for dedup check", () => {
			const request = {
				protocolId: "uniswap-v3",
				seasonId: "uniswap-v3:season-20241205-abc123",
				kind: "test",
				embedding: new Array(1536).fill(0.1),
				threshold: 0.9,
			}
			expect(() => SimilarRequestSchema.parse(request)).not.toThrow()
		})

		it("should use default values", () => {
			const request = {
				protocolId: "test",
				seasonId: "season-001",
				kind: "hypothesis",
				text: "test",
			}
			const result = SimilarRequestSchema.parse(request)
			expect(result.threshold).toBe(0.85)
			expect(result.limit).toBe(5)
		})
	})

	describe("SimilarResponseSchema", () => {
		it("should validate with duplicates found", () => {
			const response = {
				results: [
					{
						id: "artifact-001",
						similarity: 0.92,
						summary: "Similar hypothesis",
						metadata: null,
					},
				],
				isDuplicate: true,
				maxSimilarity: 0.92,
			}
			expect(() => SimilarResponseSchema.parse(response)).not.toThrow()
		})

		it("should validate with no duplicates", () => {
			const response = {
				results: [],
				isDuplicate: false,
				maxSimilarity: 0.3,
			}
			expect(() => SimilarResponseSchema.parse(response)).not.toThrow()
		})
	})

	describe("LinkRequestSchema", () => {
		it("should validate link creation", () => {
			const request = {
				protocolId: "uniswap-v3",
				seasonId: "season-001",
				parentId: "inv-001",
				childId: "path-001",
				relation: "violates",
				confidence: 0.9,
				notes: "Path exploits invariant",
			}
			expect(() => LinkRequestSchema.parse(request)).not.toThrow()
		})

		it("should validate all relation types", () => {
			const relations = [
				"derived_from",
				"violates",
				"uses",
				"depends_on",
				"tested_by",
				"confirmed_by",
				"refutes",
				"updates",
				"extends",
				"derives",
			]

			for (const relation of relations) {
				const request = {
					protocolId: "test",
					seasonId: "season-001",
					parentId: "parent-001",
					childId: "child-001",
					relation,
				}
				expect(() => LinkRequestSchema.parse(request)).not.toThrow()
			}
		})
	})

	describe("RecordFeedbackRequestSchema", () => {
		it("should validate complete feedback", () => {
			const feedback = {
				protocolId: "uniswap-v3",
				seasonId: "uniswap-v3:season-20241205-abc123",
				testId: "test-001",
				status: "pass",
				profit: 125000,
				linkedPathId: "path-001",
				linkedInvariantIds: ["inv-001", "inv-002"],
				forgeLogsContent: "[PASS] testExploit (1.5s)",
			}
			expect(() => RecordFeedbackRequestSchema.parse(feedback)).not.toThrow()
		})

		it("should validate failed feedback", () => {
			const feedback = {
				protocolId: "uniswap-v3",
				seasonId: "season-001",
				testId: "test-001",
				status: "fail",
				revertReason: "STF",
				failureDetails: "Insufficient balance",
			}
			expect(() => RecordFeedbackRequestSchema.parse(feedback)).not.toThrow()
		})

		it("should validate all test statuses", () => {
			const statuses = [
				"pending",
				"running",
				"pass",
				"fail",
				"flaky",
				"inconclusive",
				"error",
			]

			for (const status of statuses) {
				const feedback = {
					protocolId: "test",
					seasonId: "season-001",
					testId: "test-001",
					status,
				}
				expect(() =>
					RecordFeedbackRequestSchema.parse(feedback),
				).not.toThrow()
			}
		})
	})

	describe("RecordFeedbackResponseSchema", () => {
		it("should validate response with updated entities", () => {
			const response = {
				id: "feedback-001",
				updatedEntities: [
					{
						id: "path-001",
						type: "path",
						field: "confirmedCount",
						oldValue: 0,
						newValue: 1,
					},
					{
						id: "inv-001",
						type: "invariant",
						field: "isViolated",
						oldValue: false,
						newValue: true,
					},
				],
			}
			expect(() => RecordFeedbackResponseSchema.parse(response)).not.toThrow()
		})
	})

	describe("SnapshotRequestSchema", () => {
		it("should validate snapshot request", () => {
			const request = {
				seasonId: "season-001",
				protocolId: "uniswap-v3",
				metadata: { reason: "pre-refinement" },
			}
			expect(() => SnapshotRequestSchema.parse(request)).not.toThrow()
		})
	})

	describe("SnapshotResponseSchema", () => {
		it("should validate snapshot response", () => {
			const response = {
				id: "snapshot-001",
				seasonId: "season-001",
				createdAt: new Date(),
			}
			expect(() => SnapshotResponseSchema.parse(response)).not.toThrow()
		})
	})

	describe("RestoreRequestSchema", () => {
		it("should validate restore request", () => {
			const request = {
				snapshotId: "snapshot-001",
				protocolId: "uniswap-v3",
			}
			expect(() => RestoreRequestSchema.parse(request)).not.toThrow()
		})
	})

	describe("RestoreResponseSchema", () => {
		it("should validate restore response", () => {
			const response = {
				success: true,
				restoredSeasonId: "season-restored-001",
				restoredEntities: {
					graphs: 1,
					invariants: 20,
					paths: 10,
					scenarios: 5,
					tests: 3,
				},
			}
			expect(() => RestoreResponseSchema.parse(response)).not.toThrow()
		})
	})

	describe("CreateSeasonRequestSchema", () => {
		it("should validate season creation request", () => {
			const request = {
				protocolId: "uniswap-v3",
				metadata: { purpose: "mainnet audit" },
			}
			expect(() => CreateSeasonRequestSchema.parse(request)).not.toThrow()
		})

		it("should require protocolId", () => {
			const request = {}
			expect(() => CreateSeasonRequestSchema.parse(request)).toThrow()
		})
	})

	describe("CreateSeasonResponseSchema", () => {
		it("should validate season creation response", () => {
			const response = {
				id: "uniswap-v3:season-20241205-abc123",
				protocolId: "uniswap-v3",
				status: "active",
				createdAt: new Date(),
			}
			expect(() => CreateSeasonResponseSchema.parse(response)).not.toThrow()
		})
	})

	describe("CloseSeasonRequestSchema", () => {
		it("should validate close request", () => {
			const request = {
				seasonId: "season-001",
				protocolId: "uniswap-v3",
			}
			expect(() => CloseSeasonRequestSchema.parse(request)).not.toThrow()
		})
	})

	describe("CloseSeasonResponseSchema", () => {
		it("should validate close response", () => {
			const response = {
				success: true,
				finalSnapshot: "snapshot-final-001",
			}
			expect(() => CloseSeasonResponseSchema.parse(response)).not.toThrow()
		})

		it("should allow null final snapshot", () => {
			const response = {
				success: true,
				finalSnapshot: null,
			}
			expect(() => CloseSeasonResponseSchema.parse(response)).not.toThrow()
		})
	})

	describe("ImportSummariesRequestSchema", () => {
		it("should validate import request", () => {
			const request = {
				targetSeasonId: "season-new",
				sourceSeasonId: "season-old",
				protocolId: "uniswap-v3",
				importInvariants: true,
				importPaths: false,
				importQuestions: true,
				minConfidence: 0.7,
			}
			expect(() => ImportSummariesRequestSchema.parse(request)).not.toThrow()
		})

		it("should use default values", () => {
			const request = {
				targetSeasonId: "season-new",
				sourceSeasonId: "season-old",
				protocolId: "uniswap-v3",
			}
			const result = ImportSummariesRequestSchema.parse(request)
			expect(result.importInvariants).toBe(true)
			expect(result.importPaths).toBe(false)
			expect(result.importQuestions).toBe(true)
			expect(result.minConfidence).toBe(0.7)
		})
	})

	describe("ImportSummariesResponseSchema", () => {
		it("should validate import response", () => {
			const response = {
				imported: {
					invariants: 15,
					paths: 0,
					questions: 10,
				},
			}
			expect(() => ImportSummariesResponseSchema.parse(response)).not.toThrow()
		})
	})

	describe("ExploitResearchErrorSchema", () => {
		it("should validate error response", () => {
			const error = {
				error: "Season not found",
				code: "SEASON_NOT_FOUND",
				details: { seasonId: "unknown-season" },
			}
			expect(() => ExploitResearchErrorSchema.parse(error)).not.toThrow()
		})

		it("should work with minimal error", () => {
			const error = {
				error: "Internal server error",
			}
			expect(() => ExploitResearchErrorSchema.parse(error)).not.toThrow()
		})
	})
})
