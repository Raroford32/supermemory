import { z } from "zod"
import { MetadataSchema } from "./schemas"

// ============================================================================
// ENUMS
// ============================================================================

export const PhaseEnum = z.enum([
	"intake", // Source/ABI collection
	"graphing", // Contract graph construction
	"invariant", // Invariant derivation
	"violation", // Violation search
	"poc_generation", // PoC code generation
	"execution", // Foundry fork test execution
	"refinement", // Iterative improvement
])
export type Phase = z.infer<typeof PhaseEnum>

export const SeasonStatusEnum = z.enum([
	"created",
	"active",
	"paused",
	"closed",
])
export type SeasonStatus = z.infer<typeof SeasonStatusEnum>

export const ArtifactKindEnum = z.enum([
	"source",
	"abi",
	"graph",
	"invariant",
	"path",
	"hypothesis",
	"scenario",
	"test",
	"execution",
	"log",
	"question",
	"forge_output",
	"contract_outline",
	"tool_output",
])
export type ArtifactKind = z.infer<typeof ArtifactKindEnum>

export const InvariantCategoryEnum = z.enum([
	"access_control",
	"arithmetic",
	"reentrancy",
	"oracle_manipulation",
	"flash_loan",
	"price_manipulation",
	"slippage",
	"timestamp_dependency",
	"front_running",
	"governance",
	"liquidity",
	"collateral",
	"interest_rate",
	"liquidation",
	"fee_extraction",
	"donation_attack",
	"first_depositor",
	"custom",
])
export type InvariantCategory = z.infer<typeof InvariantCategoryEnum>

export const TestStatusEnum = z.enum([
	"pending",
	"running",
	"pass",
	"fail",
	"flaky",
	"inconclusive",
	"error",
])
export type TestStatus = z.infer<typeof TestStatusEnum>

export const ExploitRelationEnum = z.enum([
	"derived_from", // Created from parent
	"violates", // Path violates invariant
	"uses", // Uses contract/function
	"depends_on", // Dependency relationship
	"tested_by", // Tested by test case
	"confirmed_by", // Confirmed by execution
	"refutes", // Disproves hypothesis
	"updates", // Updates existing knowledge (from base)
	"extends", // Extends without replacing (from base)
	"derives", // Inferred connection (from base)
])
export type ExploitRelation = z.infer<typeof ExploitRelationEnum>

export const SeverityEnum = z.enum([
	"critical",
	"high",
	"medium",
	"low",
	"informational",
])
export type Severity = z.infer<typeof SeverityEnum>

// ============================================================================
// CORE ENTITIES
// ============================================================================

export const CriticalFunctionSchema = z.object({
	contract: z.string(),
	function: z.string(),
	signature: z.string(),
	risk: SeverityEnum,
})
export type CriticalFunction = z.infer<typeof CriticalFunctionSchema>

export const ProtocolSchema = z.object({
	id: z.string(), // protocol_id
	name: z.string(),
	chains: z.array(z.string()), // ["ethereum", "arbitrum"]
	type: z.string(), // "dex", "lending", "bridge"
	valueContracts: z.array(z.string()), // Addresses holding value
	criticalFunctions: z.array(CriticalFunctionSchema),
	seasonIds: z.array(z.string()),
	metadata: MetadataSchema.nullable().optional(),
	createdAt: z.coerce.date(),
	updatedAt: z.coerce.date(),
})
export type Protocol = z.infer<typeof ProtocolSchema>

export const SeasonCoverageSchema = z.object({
	contractsAnalyzed: z.number().default(0),
	functionsAnalyzed: z.number().default(0),
	invariantsGenerated: z.number().default(0),
	pathsExplored: z.number().default(0),
	scenariosGenerated: z.number().default(0),
	testsRun: z.number().default(0),
	testsPassed: z.number().default(0),
	testsFailed: z.number().default(0),
	profitableExploits: z.number().default(0),
})
export type SeasonCoverage = z.infer<typeof SeasonCoverageSchema>

export const SeasonSchema = z.object({
	id: z.string(), // season_id
	protocolId: z.string(),
	status: SeasonStatusEnum,
	startedAt: z.coerce.date(),
	closedAt: z.coerce.date().nullable().optional(),

	// Coverage statistics
	coverage: SeasonCoverageSchema,

	// Active phase tracking
	activePhases: z.array(PhaseEnum),
	currentPhase: PhaseEnum.nullable().optional(),

	// Checkpoint data
	checkpointData: z.record(z.unknown()).nullable().optional(),

	metadata: MetadataSchema.nullable().optional(),
	createdAt: z.coerce.date(),
	updatedAt: z.coerce.date(),
})
export type Season = z.infer<typeof SeasonSchema>

export const ContractSchema = z.object({
	id: z.string(),
	protocolId: z.string(),
	seasonId: z.string(),
	address: z.string(),
	chain: z.string(),
	name: z.string(),

	// Classification
	holdsValue: z.boolean().default(false),
	role: z.string().nullable().optional(), // "vault", "router", "oracle"

	// Content
	outline: z.string().nullable().optional(), // Reduced function/state summary
	abiHash: z.string().nullable().optional(),
	sourceHash: z.string().nullable().optional(),

	// References
	sourceArtifactId: z.string().nullable().optional(),
	abiArtifactId: z.string().nullable().optional(),

	metadata: MetadataSchema.nullable().optional(),
	createdAt: z.coerce.date(),
	updatedAt: z.coerce.date(),
})
export type Contract = z.infer<typeof ContractSchema>

export const GraphSchema = z.object({
	id: z.string(), // graph_id
	protocolId: z.string(),
	seasonId: z.string(),

	// Graph statistics
	nodeCount: z.number().default(0),
	edgeCount: z.number().default(0),
	graphHash: z.string(), // For change detection

	// Coverage
	contractsCovered: z.array(z.string()), // Contract IDs
	coverage: z.number().default(0), // 0-100 percentage

	// Storage reference
	graphArtifactId: z.string().nullable().optional(),

	metadata: MetadataSchema.nullable().optional(),
	createdAt: z.coerce.date(),
	updatedAt: z.coerce.date(),
})
export type Graph = z.infer<typeof GraphSchema>

export const InvariantSchema = z.object({
	id: z.string(), // invariant_id
	protocolId: z.string(),
	seasonId: z.string(),
	graphId: z.string().nullable().optional(),

	// Invariant definition
	category: InvariantCategoryEnum,
	formula: z.string(), // Logical/mathematical formula
	description: z.string(),

	// Target
	targetContract: z.string().nullable().optional(),
	targetFunction: z.string().nullable().optional(),
	variables: z.array(z.string()), // State variables involved

	// Assessment
	severity: SeverityEnum,
	confidence: z.number().min(0).max(1), // 0-1 confidence score
	sourceLocation: z.string().nullable().optional(),

	// Embeddings for similarity
	embedding: z.array(z.number()).nullable().optional(),
	embeddingModel: z.string().nullable().optional(),

	// Status
	isViolated: z.boolean().default(false),
	violationCount: z.number().default(0),

	metadata: MetadataSchema.nullable().optional(),
	createdAt: z.coerce.date(),
	updatedAt: z.coerce.date(),
})
export type Invariant = z.infer<typeof InvariantSchema>

export const PathStepSchema = z.object({
	contract: z.string(),
	function: z.string(),
	inputs: z.record(z.unknown()).nullable().optional(),
	expectedState: z.record(z.unknown()).nullable().optional(),
	notes: z.string().nullable().optional(),
})
export type PathStep = z.infer<typeof PathStepSchema>

export const PathSchema = z.object({
	id: z.string(), // path_id
	protocolId: z.string(),
	seasonId: z.string(),

	// Violation target
	violatedInvariantId: z.string(),

	// Path definition
	steps: z.array(PathStepSchema),

	// Economics
	estimatedProfit: z.number().nullable().optional(),
	requiredCapital: z.number().nullable().optional(),

	// Assessment
	confidence: z.number().min(0).max(1),
	complexity: z.number().min(1).max(10), // 1=simple, 10=complex

	// Preconditions
	assumptions: z.array(z.string()),
	preconditions: z.array(z.string()),

	// Dedup
	dedupEmbedding: z.array(z.number()).nullable().optional(),
	dedupEmbeddingModel: z.string().nullable().optional(),

	// Status
	isViable: z.boolean().default(true),
	testedCount: z.number().default(0),
	confirmedCount: z.number().default(0),

	metadata: MetadataSchema.nullable().optional(),
	createdAt: z.coerce.date(),
	updatedAt: z.coerce.date(),
})
export type Path = z.infer<typeof PathSchema>

export const ScenarioSchema = z.object({
	id: z.string(), // scenario_id
	protocolId: z.string(),
	seasonId: z.string(),
	derivedFromPathId: z.string(),

	// Economics
	grossProfit: z.number().nullable().optional(),
	netProfit: z.number().nullable().optional(),
	gasCosts: z.number().nullable().optional(),
	flashLoanFees: z.number().nullable().optional(),
	requiredCapital: z.number().nullable().optional(),

	// Contracts involved
	contractsInvolved: z.array(z.string()),

	// Assessment
	confidence: z.number().min(0).max(1),
	complexity: z.number().min(1).max(10),
	isViable: z.boolean().default(true),

	// Dedup
	dedupEmbedding: z.array(z.number()).nullable().optional(),
	dedupEmbeddingModel: z.string().nullable().optional(),

	metadata: MetadataSchema.nullable().optional(),
	createdAt: z.coerce.date(),
	updatedAt: z.coerce.date(),
})
export type Scenario = z.infer<typeof ScenarioSchema>

export const TestSchema = z.object({
	id: z.string(), // test_id
	protocolId: z.string(),
	seasonId: z.string(),
	scenarioId: z.string(),

	// Test code
	codeHash: z.string(),
	codeArtifactId: z.string().nullable().optional(),

	// Status
	status: TestStatusEnum,

	// Fork configuration
	forkRpc: z.string().nullable().optional(),
	forkBlock: z.number().nullable().optional(),

	// Results
	forgeLogsRef: z.string().nullable().optional(),
	coverage: z.number().nullable().optional(), // 0-100

	// Dedup
	dedupEmbedding: z.array(z.number()).nullable().optional(),
	dedupEmbeddingModel: z.string().nullable().optional(),

	metadata: MetadataSchema.nullable().optional(),
	createdAt: z.coerce.date(),
	updatedAt: z.coerce.date(),
})
export type Test = z.infer<typeof TestSchema>

export const ExecutionSchema = z.object({
	id: z.string(),
	protocolId: z.string(),
	seasonId: z.string(),
	testId: z.string(),

	// Results
	status: TestStatusEnum,
	profit: z.number().nullable().optional(),
	failureReason: z.string().nullable().optional(),
	revertReason: z.string().nullable().optional(),

	// Environment
	forkRpc: z.string(),
	forkBlock: z.number(),

	// Artifacts
	logsArtifactId: z.string().nullable().optional(),
	traceArtifactId: z.string().nullable().optional(),

	// Metrics
	gasUsed: z.number().nullable().optional(),
	executionTime: z.number().nullable().optional(),

	metadata: MetadataSchema.nullable().optional(),
	createdAt: z.coerce.date(),
})
export type Execution = z.infer<typeof ExecutionSchema>

// ============================================================================
// EVENT LOG & ARTIFACTS
// ============================================================================

export const ToolEventSchema = z.object({
	id: z.string(), // tool_call_id
	protocolId: z.string(),
	seasonId: z.string(),
	phase: PhaseEnum,

	// Tool info
	toolName: z.string(),
	toolCallId: z.string(), // External tool call ID

	// Target
	targetContract: z.string().nullable().optional(),
	targetFunction: z.string().nullable().optional(),
	targetInvariantId: z.string().nullable().optional(),
	targetPathId: z.string().nullable().optional(),
	targetTestId: z.string().nullable().optional(),

	// Result
	success: z.boolean(),
	duration: z.number().nullable().optional(), // ms

	// Token tracking
	inputTokens: z.number().nullable().optional(),
	outputTokens: z.number().nullable().optional(),
	costUsd: z.number().nullable().optional(),

	// References
	rawRef: z.string().nullable().optional(), // Artifact ID for raw output
	summaryRef: z.string().nullable().optional(), // Artifact ID for summary
	embeddingId: z.string().nullable().optional(),

	metadata: MetadataSchema.nullable().optional(),
	createdAt: z.coerce.date(),
})
export type ToolEvent = z.infer<typeof ToolEventSchema>

export const ArtifactSchema = z.object({
	id: z.string(), // artifact_id
	protocolId: z.string(),
	seasonId: z.string(),

	// Type
	kind: ArtifactKindEnum,

	// Content
	raw: z.string().nullable().optional(), // Raw content (may be large)
	rawHash: z.string().nullable().optional(), // For dedup
	summary: z.string().nullable().optional(), // Reduced content

	// Embeddings
	embedding: z.array(z.number()).nullable().optional(),
	embeddingModel: z.string().nullable().optional(),

	// Size tracking
	rawSize: z.number().nullable().optional(), // bytes
	summarySize: z.number().nullable().optional(),

	// Retention
	retainUntil: z.coerce.date().nullable().optional(),

	// Security
	isSensitive: z.boolean().default(false), // Contains sensitive info
	sensitivityTypes: z.array(z.string()).nullable().optional(), // Types of sensitive content
	wasRedacted: z.boolean().default(false), // Content was redacted

	metadata: MetadataSchema.nullable().optional(),
	createdAt: z.coerce.date(),
	updatedAt: z.coerce.date(),
})
export type Artifact = z.infer<typeof ArtifactSchema>

export const QuestionSchema = z.object({
	id: z.string(),
	protocolId: z.string(),
	seasonId: z.string(),

	// Question content
	text: z.string(),
	category: z.string().nullable().optional(),

	// Performance tracking
	successRate: z.number().default(0), // 0-1
	timesAsked: z.number().default(0),

	// Links
	linkedInvariantId: z.string().nullable().optional(),
	linkedPathId: z.string().nullable().optional(),

	// Embeddings
	embedding: z.array(z.number()).nullable().optional(),
	embeddingModel: z.string().nullable().optional(),

	metadata: MetadataSchema.nullable().optional(),
	createdAt: z.coerce.date(),
	updatedAt: z.coerce.date(),
})
export type Question = z.infer<typeof QuestionSchema>

// ============================================================================
// RELATIONS
// ============================================================================

export const EntityRelationSchema = z.object({
	id: z.string(),
	parentId: z.string(),
	childId: z.string(),
	relation: ExploitRelationEnum,

	// Context
	protocolId: z.string(),
	seasonId: z.string(),

	// Metadata
	confidence: z.number().min(0).max(1).nullable().optional(),
	notes: z.string().nullable().optional(),

	createdAt: z.coerce.date(),
})
export type EntityRelation = z.infer<typeof EntityRelationSchema>

// ============================================================================
// FEEDBACK
// ============================================================================

export const FeedbackSchema = z.object({
	id: z.string(),
	protocolId: z.string(),
	seasonId: z.string(),
	testId: z.string(),

	// Result
	status: TestStatusEnum,

	// Details
	profit: z.number().nullable().optional(),
	revertReason: z.string().nullable().optional(),
	failureDetails: z.string().nullable().optional(),

	// Linked entities to update
	linkedPathId: z.string().nullable().optional(),
	linkedScenarioId: z.string().nullable().optional(),
	linkedInvariantIds: z.array(z.string()).nullable().optional(),

	// Forge logs
	forgeLogsRef: z.string().nullable().optional(),

	metadata: MetadataSchema.nullable().optional(),
	createdAt: z.coerce.date(),
})
export type Feedback = z.infer<typeof FeedbackSchema>

// ============================================================================
// SNAPSHOT
// ============================================================================

export const SeasonSnapshotSchema = z.object({
	id: z.string(),
	seasonId: z.string(),
	protocolId: z.string(),

	// State at snapshot time
	coverage: SeasonCoverageSchema,
	activePhases: z.array(PhaseEnum),
	currentPhase: PhaseEnum.nullable().optional(),

	// Active entity IDs
	activeGraphIds: z.array(z.string()),
	activeInvariantIds: z.array(z.string()),
	activePathIds: z.array(z.string()),
	activeScenarioIds: z.array(z.string()),
	activeTestIds: z.array(z.string()),

	// Checkpoint data
	checkpointData: z.record(z.unknown()).nullable().optional(),

	metadata: MetadataSchema.nullable().optional(),
	createdAt: z.coerce.date(),
})
export type SeasonSnapshot = z.infer<typeof SeasonSnapshotSchema>

// ============================================================================
// EXPORTS
// ============================================================================

export const exploitResearchSchemas = {
	// Enums
	PhaseEnum,
	SeasonStatusEnum,
	ArtifactKindEnum,
	InvariantCategoryEnum,
	TestStatusEnum,
	ExploitRelationEnum,
	SeverityEnum,

	// Core entities
	CriticalFunctionSchema,
	ProtocolSchema,
	SeasonCoverageSchema,
	SeasonSchema,
	ContractSchema,
	GraphSchema,
	InvariantSchema,
	PathStepSchema,
	PathSchema,
	ScenarioSchema,
	TestSchema,
	ExecutionSchema,

	// Event & Artifacts
	ToolEventSchema,
	ArtifactSchema,
	QuestionSchema,

	// Relations
	EntityRelationSchema,

	// Feedback
	FeedbackSchema,

	// Snapshot
	SeasonSnapshotSchema,
} as const
